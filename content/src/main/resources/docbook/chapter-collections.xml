<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<chapter id="collections" label="5">
  <title>Collections</title>

  <sect1 id="collections-sect-intro">
    <title>Introduction</title>

    <para>Java 2 Standard Edition (J2SE) introduced the Collections API—a
    dramatic improvement over <literal moreinfo="none">Vector</literal> and
    <literal moreinfo="none">Hashtable</literal> in Java 1.1. This new API
    provides <literal moreinfo="none">Set</literal>, <literal
    moreinfo="none">List</literal>, <literal moreinfo="none">Map</literal>,
    and <literal moreinfo="none">Iterator</literal> interfaces with various
    implementations addressing different needs for different applications.
    Despite the additions and improvements, there are still gaps in the Java's
    Collections API—functionality that is addressed by a supplemental library,
    Jakarta Commons Collections. Most of the features introduced in Jakarta
    Commons Collections are easily anticipated extensions of the Java 2
    platform: a reversible <literal moreinfo="none">Comparator</literal> or a
    <literal moreinfo="none">Bag</literal> interface, for example. Other
    concepts in Commons Collections are innovative additions to the
    J2SE—predicated collections, self-validating collections, set operations,
    and lazy collections using transformers. Commons Collections 3.0 also
    introduces the concept of functors (see <link
    linkend="jakartackbk-CHP-4">Chapter 4</link>).</para>

    <para>Java 5.0 (a.k.a. Tiger) has introduced a number of new language
    features and improvements to the Collections API. A <literal
    moreinfo="none">Queue</literal> class and type-safe generics are two major
    additions that will become available to most programmers with the
    production-ready release of 5.0. Some recipes in this chapter introduce
    utilities that overlap the functionality of 5.0, and, if a recipe
    introduces a utility with an analog in 5.0, an effort has been made to
    identify any opportunity to achieve the same result with new 5.0 classes
    and features.</para>
  </sect1>

  <sect1 id="collections-sect-obtaining" label="5.1" role="Recipe">
    <title>Obtaining Commons Collections</title>

    <sect2>
      <title>Problem</title>

      <para>You need to use Jakarta <indexterm
          id="jakartackbk-CHP-5-ITERM-2412" significance="normal">
          <primary>Commons Collections</primary>

          <secondary>downloading</secondary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2413"
          significance="normal">
          <primary>collections</primary>

          <secondary>downloading</secondary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2414"
          significance="normal">
          <primary>downloading</primary>

          <secondary>collections</secondary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2415"
          significance="normal">
          <primary>objects</primary>

          <secondary>Collections</secondary>

          <tertiary>downloading</tertiary>
        </indexterm>Commons Collections because your application makes heavy
      use of <literal moreinfo="none">Collection</literal> objects, and you
      wish to use some of the utilities provided by this component.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Commons Collections was introduced in <link
      linkend="jakartackbk-CHP-4">Chapter 4</link>. For instructions on
      obtaining Collections, see <link
      linkend="jakartackbk-CHP-4-SECT-1">Recipe 4.1</link>.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>For more information about the Commons Collections project, see
      the project page at <systemitem moreinfo="none"
      role="url">http://jakarta.apache.org/commons/collections</systemitem>.
      If you have questions about using Commons Collections, feel free to join
      the <systemitem moreinfo="none"
      role="url">commons-user@jakarta.apache.org</systemitem> mailing list.
      Instructions for joining the user mailing list can be found in <link
      linkend="jakartackbk-CHP-1-SECT-2">Recipe 1.2</link>. For information on
      obtaining the source code for Commons Collections, see <link
      linkend="jakartackbk-CHP-4-SECT-2">Recipe 4.2</link>.</para>
    </sect2>
  </sect1>

  <sect1 id="collections-sect-use-looping" label="5.2" role="Recipe">
    <title>Using a Looping Iterator</title>

    <sect2>
      <title>Problem</title>

      <para>You need to loop through the<indexterm
          id="jakartackbk-CHP-5-ITERM-2416" significance="normal">
          <primary>Commons Collections</primary>

          <secondary>loops</secondary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2417"
          significance="normal">
          <primary>collections</primary>

          <secondary>loops</secondary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2418"
          significance="normal">
          <primary>loops</primary>

          <secondary>collections</secondary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2419"
          significance="normal">
          <primary>objects</primary>

          <secondary>Collections</secondary>

          <tertiary>loops</tertiary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2420"
          significance="normal">
          <primary>iteration</primary>

          <secondary>looping</secondary>
        </indexterm> contents of a <literal
      moreinfo="none">Collection</literal>.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use a <literal moreinfo="none">LoopingIterator</literal>
      <indexterm id="jakartackbk-CHP-5-ITERM-2421" significance="normal">
          <primary>LoopingIterator</primary>
        </indexterm> to repeatedly iterate through the contents of a <literal
      moreinfo="none">Collection</literal>. Pass an existing <literal
      moreinfo="none">Collection</literal> to the constructor of <literal
      moreinfo="none">LoopingIterator</literal>, and call<indexterm
          id="jakartackbk-CHP-5-ITERM-2422" significance="normal">
          <primary>iterator( ) method</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2423"
          significance="normal">
          <primary>methods</primary>

          <secondary>iterator( )</secondary>
        </indexterm> <literal moreinfo="none">iterator( )</literal>. The
      following code uses a <literal moreinfo="none">LoopingIterator</literal>
      to retrieve five items from a <literal moreinfo="none">List</literal>
      with three items:</para>

      <programlisting format="linespecific" id="I_5_tt200">List drivers = new ArrayList( );

drivers.add( "Chris" );
drivers.add( "Sean" );
drivers.add( "Kathy" );

LoopingIterator loopingIterator = new LoopingIterator( drivers );

for( int i = 1; i &lt;= 5; i++ ) {
    String driver = (String) loopingIterator.next( );
    System.out.println( "Driver for Day " + i + ": " + driver );
}</programlisting>

      <para>The previous example simulates the selection of a driver in a car
      pool with three drivers. Five drivers are selected, and the <literal
      moreinfo="none">LoopingIterator</literal> returns the first item in the
      <literal moreinfo="none">List</literal> on the fourth day:</para>

      <programlisting format="linespecific" id="I_5_tt201">Driver for Day 1: Chris
Driver for Day 2: Sean
Driver for Day 3: Kathy
Driver for Day 4: Chris
Driver for Day 5: Sean</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Keep in mind that a <literal
      moreinfo="none">LoopingIterator</literal> never stops iterating;
      <literal moreinfo="none">hasNext( )</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2424" significance="normal">
          <primary>hasNext( ) method</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2425"
          significance="normal">
          <primary>methods</primary>

          <secondary>hasNext( )</secondary>
        </indexterm> always returns <literal moreinfo="none">true</literal> in
      a <literal moreinfo="none">LoopingIterator</literal>. If you are using a
      <literal moreinfo="none">LoopingIterator</literal> with a <literal
      moreinfo="none">while</literal> loop, be sure to code an exit condition.
      A <literal moreinfo="none">LoopingIterator</literal> is appropriate for
      a situation in which a series of values must be repeatedly evaluated, or
      a loop of commands must be repeatedly executed. An application, for
      example, may have a series of components that need to be continuously
      updated, or a series of queues or buffers that need to be continuously
      tested or monitored—an event loop, for example.</para>

      <para>The <literal moreinfo="none">LoopingIterator</literal> also
      implements the Commons Collections interface <literal
      moreinfo="none">ResettableIterator</literal>; this extension of the
      <literal moreinfo="none">Iterator</literal> interface can be reset to
      start at the beginning of a <literal
      moreinfo="none">Collection</literal>. When using a <literal
      moreinfo="none">ResettableIterator</literal>, call <literal
      moreinfo="none">reset()</literal> to jump back to the beginning of a
      <literal moreinfo="none">Collection</literal>:</para>

      <programlisting format="linespecific" id="I_5_tt202">List items = new ArrayList( );

items.add( "Item 1" );
items.add( "Item 2" );
items.add( "Item 3" );

LoopingIterator iterator = new LoopingIterator( items );

// Print out two elements from the LoopingIterator
System.out.println( iterator.next( ) );
System.out.println( iterator.next( ) );

// Reset iterator to start of List
System.out.println( "Reset" );
iterator.reset( );

// Print out two elements from the LoopingIterator
System.out.println( iterator.next( ) );
System.out.println( iterator.next( ) );</programlisting>

      <para>This example iterates over the first two elements in a <literal
      moreinfo="none">List</literal> before calling <literal
      moreinfo="none">reset( )</literal>. After calling <literal
      moreinfo="none">reset( )</literal>, the code calls <literal
      moreinfo="none">next( )</literal> twice, printing out the first two
      elements, as shown below:</para>

      <programlisting format="linespecific" id="I_5_tt203">Item 1
Item 2
Reset
Item 1
Item 2</programlisting>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para><link linkend="jakartackbk-CHP-5-SECT-3">Recipe 5.3</link> deals
      with another implementation of <literal
      moreinfo="none">ResettableIterator</literal>, <literal
      moreinfo="none">ArrayListIterator</literal>, which can be used to
      iterate over a subset of elements in an <literal
      moreinfo="none">ArrayList</literal>.</para>
    </sect2>
  </sect1>

  <sect1 id="collections-sect-iterating-arraylist" label="5.3" role="Recipe">
    <title>Iterating Over an ArrayList</title>

    <sect2>
      <title>Problem</title>

      <para>You need to iterate<indexterm id="jakartackbk-CHP-5-ITERM-2426"
          significance="normal">
          <primary>Commons Collections</primary>

          <secondary>ArrayLists</secondary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2427"
          significance="normal">
          <primary>collections</primary>

          <secondary>ArrayLists</secondary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2428"
          significance="normal">
          <primary>ArrayLists, collections</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2429"
          significance="normal">
          <primary>objects</primary>

          <secondary>Collections</secondary>

          <tertiary>ArrayLists</tertiary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2430"
          significance="normal">
          <primary>iteration</primary>

          <secondary>ArrayLists</secondary>
        </indexterm> over a portion of an <literal
      moreinfo="none">ArrayList</literal>. For example, you have an <literal
      moreinfo="none">ArrayList</literal> with 30 elements, and you need to
      iterate from index 0 to index 20.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use an <literal moreinfo="none">ArrayListIterator</literal>
      <indexterm id="jakartackbk-CHP-5-ITERM-2431" significance="normal">
          <primary>ArrayListIterator</primary>
        </indexterm> to iterate through a specified region of an <literal
      moreinfo="none">ArrayList</literal>. This implementation of <literal
      moreinfo="none">Iterator</literal> is constructed with a reference to an
      <literal moreinfo="none">ArrayList</literal> and two optional parameters
      that specify the start and end of an iteration. This example
      demonstrates the use of <literal
      moreinfo="none">ArrayListIterator</literal> to iterate over the 3rd,
      4th, and 5th elements of an <literal
      moreinfo="none">ArrayList</literal>:</para>

      <programlisting format="linespecific" id="I_5_tt204">String[] strings = new String[] { "A", "B", "C", "D", "E", "F" };
List list = new ArrayList( Arrays.asList( strings ) );

Iterator iterator = new ArrayListIterator( list, 3, 6 );
while( iterator.hasNext( ) ) {
        int index = iterator.nextIndex( );
    String element = (String) iterator.next( );
    System.out.println( "Element at " + index + ": " + element );
}</programlisting>

      <para><literal moreinfo="none">ArrayListIterator</literal> also allows
      you to obtain the index of an element during an iteration. In the
      previous example, <literal
      moreinfo="none">iterator.nextIndex()</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2432" significance="normal">
          <primary>iterator.nextIndex( ) method</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2433"
          significance="normal">
          <primary>methods</primary>

          <secondary>iterator.nextIndex( )</secondary>
        </indexterm> returns the index of the element returned by the
      subsequent call to<indexterm id="jakartackbk-CHP-5-ITERM-2434"
          significance="normal">
          <primary>iterator.next( ) method</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2435"
          significance="normal">
          <primary>methods</primary>

          <secondary>iterator.next( )</secondary>
        </indexterm> <literal moreinfo="none">iterator.next( )</literal>. The
      code above iterates through three elements of the <literal
      moreinfo="none">ArrayList</literal>, producing the following
      output:</para>

      <programlisting format="linespecific" id="I_5_tt205">Element at 3: D
Element at 4: E
Element at 5: F</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>You can construct an <literal
      moreinfo="none">ArrayListIterator</literal> with up to three arguments.
      The first argument is the <literal moreinfo="none">ArrayList</literal>
      to be iterated over. The second optional argument specifies the
      inclusive start index, and the third optional argument specifies the
      exclusive end index. If only two parameters are supplied to the
      constructor, the <literal moreinfo="none">ArrayListIterator</literal>
      will iterate until the end of the <literal
      moreinfo="none">ArrayList</literal> is reached. The following code
      demonstrates the three constructors of <literal
      moreinfo="none">ArrayListIterator</literal>:</para>

      <programlisting format="linespecific" id="I_5_tt206">String[] strings = new String[] { "A", "B", "C", "D", "E", "F" };
List list = new ArrayList( Arrays.asList( strings ) );

// Iterate over all elements
Iterator iterator1 = new ArrayListIterator( list );

// Iterate over "C", "D", "E", "F"
Iterator iterator2 = new ArrayListIterator( list, 2 );

// Iterate over "B", "C", "D"
Iterator iterator3 = new ArrayListIterator( list, 1, 4 );</programlisting>

      <para><literal moreinfo="none">ArrayListIterator</literal> implements
      the <literal moreinfo="none">ResettableIterator</literal> interface,
      which provides one function: <literal moreinfo="none">reset(
      )</literal>. The <literal moreinfo="none">reset()</literal> method takes
      the iterator back to the beginning of an iteration. After a reset, a
      call to <literal moreinfo="none">next( )</literal> returns the first
      element that an <literal moreinfo="none">ArrayListIterator</literal> has
      been configured to return—the element at the index specified in the
      constructor's optional second parameter. An <literal
      moreinfo="none">ArrayListIterator</literal> also provides a way to set
      the current element: the <literal moreinfo="none">set( )</literal>
      method takes an object parameter and changes the contents of the
      underlying <literal moreinfo="none">ArrayList</literal>. The following
      example demonstrates both the <literal moreinfo="none">reset(
      )</literal> <indexterm id="jakartackbk-CHP-5-ITERM-2436"
          significance="normal">
          <primary>reset( ) method</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2437"
          significance="normal">
          <primary>methods</primary>

          <secondary>reset( )</secondary>
        </indexterm> and <literal moreinfo="none">set()</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2438" significance="normal">
          <primary>set( ) method</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2439"
          significance="normal">
          <primary>methods</primary>

          <secondary>set( )</secondary>
        </indexterm> methods on <literal
      moreinfo="none">ArrayListIterator</literal>:</para>

      <programlisting format="linespecific" id="I_5_tt207">String[] strings = new String[] { "A", "B", "C", "D", "E", "F" };
List list = new ArrayList( Arrays.asList( strings ) );

System.out.println( "Original List: " + Arrays.toString( list.toArray( ) );

ResettableIterator iterator = new ArrayListIterator( list, 2 );

// Retrieve an Element from the List
int index = iterator.nextIndex( );
String element = (String) iterator.next( );
System.out.println( "Element at " + index + ": " + element );

// Set the Current Element
iterator.set( "G" );
System.out.println( "Modifying index: " + index + " to G");

// Retrieve the Next Element from the List
index = iterator.nextIndex( );
element = (String) iterator.next( );
System.out.println( "Element at " + index + ": " + element );

// Set the Current Element
iterator.set( "H" );
System.out.println( "Modifying index: " + index + " to H");

// Reset the Iterator (Go to beginning of iteration)
iterator.reset( );
System.out.println( "Reset" );

index = iterator.nextIndex( );
element = (String) iterator.next( );
System.out.println( "Element at " + index + ": " + element );

System.out.println( "Modified List: " + Arrays.toString( list.toArray( ) );</programlisting>

      <para>This example iterates through the <literal
      moreinfo="none">ArrayList</literal>, modifying two elements before
      calling <literal moreinfo="none">reset( )</literal>. The following
      output shows that after a <literal moreinfo="none">reset( )</literal>,
      the first element returns the value, which was supplied to <literal
      moreinfo="none">set( )</literal>:</para>

      <programlisting format="linespecific" id="I_5_tt208">Original List: {A,B,C,D,E,F}
Element at 2: C
Modifying index: 2 to G
Element at 3: D
Modifying index: 3 to H
Reset
Element at 2: G
Modified List: {A,B,G,H,E,F}</programlisting>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>If you need to iterate over an array or an object array, use two
      related implementations of <literal moreinfo="none">Iterator</literal>:
      <literal moreinfo="none">ArrayIterator</literal> and <literal
      moreinfo="none">ObjectArrayIterator</literal>. See the Commons
      Collections project page at <systemitem moreinfo="none"
      role="url">http://jakarta.apache.org/commons/collections</systemitem>
      for more information about these <literal
      moreinfo="none">Iterator</literal> implementations.</para>
    </sect2>
  </sect1>

  <sect1 id="collections-sect-filtering" label="5.4" role="Recipe">
    <title>Filtering a Collection with a Predicate</title>

    <sect2>
      <title>Problem</title>

      <para>You need to iterate through<indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2440" significance="normal">
          <primary>Commons Collections</primary>

          <secondary>predicates</secondary>

          <tertiary>filtering with</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2441" significance="normal">
          <primary>collections</primary>

          <secondary>predicates, filtering with</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2442" significance="normal">
          <primary>filtering</primary>

          <secondary>collections</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2443" significance="normal">
          <primary>objects</primary>

          <secondary>Collections</secondary>

          <tertiary>filtering with predicates</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2444" significance="normal">
          <primary>predicates</primary>

          <secondary>collections, filtering with</secondary>
        </indexterm> elements of a <literal
      moreinfo="none">Collection</literal> that match a specified condition.
      Or, you have a <literal moreinfo="none">Collection</literal> from which
      you need to remove elements not satisfying a condition.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Create a <literal moreinfo="none">FilterIterator</literal>
      <indexterm id="jakartackbk-CHP-5-ITERM-2445" significance="normal">
          <primary>FilterIterator</primary>
        </indexterm> with a <literal moreinfo="none">Predicate</literal>; if
      the <literal moreinfo="none">Predicate</literal> returns <literal
      moreinfo="none">true</literal> for an element, that element will be
      included in the <literal moreinfo="none">Iterator</literal>. The
      <literal moreinfo="none">FilterIterator</literal> decorates another
      <literal moreinfo="none">Iterator</literal> and provides the ability to
      apply an arbitrary filter to a <literal
      moreinfo="none">Collection</literal>. In the following example, <literal
      moreinfo="none">EarthQuake</literal> beans are kept in an <literal
      moreinfo="none">ArrayList</literal> that is filtered using the<indexterm
          id="jakartackbk-CHP-5-ITERM-2446" significance="normal">
          <primary>MajorQuakePredicate</primary>
        </indexterm> <literal moreinfo="none">majorQuakePredicate</literal>
      and a <literal moreinfo="none">FilterIterator</literal>:</para>

      <programlisting format="linespecific" id="I_5_tt209">import org.apache.commons.collection.Predicate;
import org.apache.commons.collection.iterators.FilterIterator;

List quakes = new ArrayList( );

EarthQuake quake1 = new EarthQuake( );
quake1.setLocation( "Chicago, IL" );
quake1.setIntensity( new Float( 6.4f ) );
quake1.setIntensity( new Float( 634.23f ) );
quake1.setTime( new Date( ) );
quakes.add( quake1 );

EarthQuake quake2 = new EarthQuake( );
quake2.setLocation( "San Francisco, CA" );
quake2.setIntensity( new Float( 4.4f ) );
quake2.setIntensity( new Float( 63.23f ) );
quake2.setTime( new Date( ) );
quakes.add( quake2 );

<userinput moreinfo="none">Predicate majorQuakePredicate = </userinput>
               <userinput moreinfo="none">    new MajorQuakePredicate( new Float(5.0), new Float(1000.0) );</userinput>

               <userinput moreinfo="none">Iterator majorQuakes = </userinput>
               <userinput moreinfo="none">    new FilterIterator( quakes.iterator( ), majorQuakePredicate );</userinput>

while( majorQuakes.hasMore( ) ) {
    EarthQuake quake = (EarthQuake) majorQuakes.next( );
    System.out.println( "ALERT! MAJOR QUAKE: " 
        + quake.getLocation( ) + ": " + quake.getIntensity( ) );
}</programlisting>

      <para>An instance of <literal
      moreinfo="none">MajorQuakePredicate</literal> is created, and it is
      passed to a <literal moreinfo="none">FilterIterator</literal>. Quakes
      satisfying the criteria are returned by the <literal
      moreinfo="none">FilterIterator</literal> and printed to the
      console:</para>

      <programlisting format="linespecific" id="I_5_tt210">ALERT! MAJOR QUAKE: Chicago, IL: 6.4</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>The Solution uses a custom <literal
      moreinfo="none">Predicate</literal> to select a subset of a <literal
      moreinfo="none">Collection</literal>, filtering <literal
      moreinfo="none">EarthQuake</literal> beans and alerting the user if a
      major earthquake is measured. An earthquake is classified by intensity
      on the Richter scale and the depth of the epicenter; this information is
      modeled by the <literal moreinfo="none">EarthQuake</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2447" significance="normal">
          <primary>EarthQuake bean</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2448"
          significance="normal">
          <primary>beans</primary>

          <secondary>EarthQuake</secondary>
        </indexterm> bean defined in <link
      linkend="jakartackbk-CHP-5-EX-1">Example 5-1</link>.</para>

      <example id="jakartackbk-CHP-5-EX-1" label="5-1">
        <title>An EarthQuake bean</title>

        <programlisting format="linespecific">package com.discursive.jccook.collections.predicates;

public class EarthQuake {
    private String location;
    private Float intensity;
    private Float depth;
    private Date time;

    public class EarthQuake( ) {}

    public String getLocation( ) { return location; }
    public void setLocation(String location) { this.location = location; }

    public Float getIntensity( ) { return intensity; }
    public void setInsensity(Float intensity) { this.intensity = intensity; }

    public Float getDepth( ) { return depth; }
    public void setDepth(Float depth) { this.depth = depth; }

    public Date getTime( ) { return time; }
    public void setTime(Date time) { this.time = time; }
}</programlisting>
      </example>

      <para>An earthquake is considered major if it is above a five on the
      Richter scale and above a depth of 1000 meters. To test each <literal
      moreinfo="none">EarthQuake</literal> object, a custom <literal
      moreinfo="none">Predicate</literal>, <literal
      moreinfo="none">MajorQuakePredicate</literal>, evaluates <literal
      moreinfo="none">EarthQuake</literal> objects, returning <literal
      moreinfo="none">true</literal> if an earthquake satisfies the criteria
      for a major earthquake. The <literal moreinfo="none">Predicate</literal>
      defined in <link linkend="jakartackbk-CHP-5-EX-2">Example 5-2</link>
      encapsulates this decision logic.</para>

      <example id="jakartackbk-CHP-5-EX-2" label="5-2">
        <title>Major earthquake classification Predicate</title>

        <programlisting format="linespecific">package com.discursive.jccook.collections.predicates;

import org.apache.commons.collections.Predicate;

public class MajorQuakePredicate implements Predicate {
    private Float majorIntensity;
    private Float majorDepth;

    public MajorQuakePredicate(Float majorIntensity, Float majorDepth) {
        this.majorIntensity = majorIntensity;
        this.majorDepth = majorDepth;
    }
    
    public boolean evaluate(Object object) {
        private satisfies = false;

        if( object instanceof EarthQuake) {
            EarthQuake quake = (EarthQuake) object;
            if( quake.getIntensity( ).floatValue( ) &gt; majorIntensity.
                floatValue( ) &amp;&amp;
                quake.getDepth( ).floatValue( ) &lt; majorDepth.
                floatValue( ) ) {
                satisfies = true;
            }
        }
        return satisfies;
    }
}</programlisting>
      </example>

      <para>If you want to create a <literal
      moreinfo="none">Collection</literal> of elements that match a <literal
      moreinfo="none">Predicate</literal>, you can remove elements from a
      <literal moreinfo="none">Collection</literal> using <literal
      moreinfo="none">CollectionUtils.filter( )</literal>. <literal
      moreinfo="none">CollectionUtils.filter( )</literal> is destructive; it
      removes elements from a <literal moreinfo="none">Collection</literal>.
      The following example demonstrates the use <literal
      moreinfo="none">CollectionUtils.filter()</literal> to remove nonmatching
      elements from a <literal moreinfo="none">Collection</literal>:</para>

      <programlisting format="linespecific" id="I_5_tt211">import org.apache.commons.collection.Predicate;
import org.apache.commons.collection.iterators.FilterIterator;

ArrayList quakes = createQuakes( );

<userinput moreinfo="none">Predicate majorQuakePredicate = </userinput>
               <userinput moreinfo="none">    new MajorQuakePredicate( new Float(5.0), new Float(1000.0) );</userinput>

               <userinput moreinfo="none">CollectionUtils.filter( quakes, majorQuakePredicate );</userinput>
            </programlisting>

      <para>After the execution of this code, <literal
      moreinfo="none">quakes</literal> will only contain <literal
      moreinfo="none">EarthQuake</literal> objects that satisfy the <literal
      moreinfo="none">MajorQuakePredicate</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2449" significance="normal">
          <primary>MajorQuakePredicate</primary>
        </indexterm>. If you don't want to alter or modify an existing
      <literal moreinfo="none">Collection</literal>, use <literal
      moreinfo="none">CollectionUtils.select()</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2450" significance="normal">
          <primary>CollectionUtils.select( ) method</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2451"
          significance="normal">
          <primary>methods</primary>

          <secondary>CollectionUtils.select( )</secondary>
        </indexterm> or <literal
      moreinfo="none">CollectionUtils.selectRejected()</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2452" significance="normal">
          <primary>CollectionUtils.selectRejected( ) method</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2453"
          significance="normal">
          <primary>methods</primary>

          <secondary>CollectionUtils.selectRejected( )</secondary>
        </indexterm> to create a new <literal
      moreinfo="none">Collection</literal> with matching or nonmatching
      elements. The following example demonstrates the use of <literal
      moreinfo="none">CollectionUtils.select( )</literal> and <literal
      moreinfo="none">CollectionUtils.selectRejected( )</literal> to select
      elements from a <literal moreinfo="none">Collection</literal> leaving
      the original <literal moreinfo="none">Collection</literal>
      unaffected:</para>

      <programlisting format="linespecific" id="I_5_tt212">import org.apache.commons.collection.Predicate;
import org.apache.commons.collection.iterators.FilterIterator;

ArrayList quakes = createQuakes( );

<userinput moreinfo="none">Predicate majorQuakePredicate = </userinput>
               <userinput moreinfo="none">    new MajorQuakePredicate( new Float(5.0), new Float(1000.0) );</userinput>

               <userinput moreinfo="none">Collection majorQuakes = CollectionUtils.select( quakes, majorQuakePredicate );</userinput>
               <userinput moreinfo="none">Collection minorQuakes = </userinput>
               <userinput moreinfo="none">    CollectionUtils.selectRejected( quakes, majorQuakePredicate );</userinput>
            </programlisting>

      <para>The <literal moreinfo="none">majorQuakes</literal> <literal
      moreinfo="none">Collection</literal> contains <literal
      moreinfo="none">EarthQuake</literal> objects satisfying the <literal
      moreinfo="none">majorQuakePredicate</literal>, and the <literal
      moreinfo="none">minorQuakes</literal> <literal
      moreinfo="none">Collection</literal> contains <literal
      moreinfo="none">EarthQuake</literal> objects not satisfying the <literal
      moreinfo="none">majorQuakePredicate</literal>. The <literal
      moreinfo="none">quakes List</literal> is not modified by <literal
      moreinfo="none">select( )</literal> or <literal
      moreinfo="none">selectRejected( )</literal>.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>Collections can be filtered via a combination <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2454"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2440"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2455"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2441"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2456"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2442"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2457"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2443"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2458"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2444"></indexterm>of <literal
      moreinfo="none">CollectionUtils</literal> and <literal
      moreinfo="none">Predicate</literal> objects, or you can also select
      elements from a <literal moreinfo="none">Collection</literal> using an
      XPath expression. <link linkend="jakartackbk-CHP-12-SECT-1">Recipe
      12.1</link> demonstrates the use on Commons JXPath to query a <literal
      moreinfo="none">Collection</literal>.</para>
    </sect2>
  </sect1>

  <sect1 id="collections-sect-iterating-distinct" label="5.5" role="Recipe">
    <title>Iterating Through Distinct Elements</title>

    <sect2>
      <title>Problem</title>

      <para>You need to iterate over the<indexterm
          id="jakartackbk-CHP-5-ITERM-2459" significance="normal">
          <primary>Commons Collections</primary>

          <secondary>element iteration</secondary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2460"
          significance="normal">
          <primary>collections</primary>

          <secondary>element iteration</secondary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2461"
          significance="normal">
          <primary>elements, collection iteration</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2462"
          significance="normal">
          <primary>objects</primary>

          <secondary>Collections</secondary>

          <tertiary>iteration</tertiary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2463"
          significance="normal">
          <primary>iteration</primary>

          <secondary>elements</secondary>
        </indexterm> unique elements in a <literal
      moreinfo="none">Collection</literal>.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use a <literal moreinfo="none">UniqueFilterIterator</literal> to
      iterate over distinct elements contained in a <literal
      moreinfo="none">Collection</literal>. <literal
      moreinfo="none">UniqueFilterIterator</literal> wraps another instance of
      <literal moreinfo="none">Iterator</literal>, keeping track of all the
      objects returned by that <literal moreinfo="none">Iterator</literal>.
      When calling <literal moreinfo="none">next( )</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2464" significance="normal">
          <primary>next( ) method</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2465"
          significance="normal">
          <primary>methods</primary>

          <secondary>next( )</secondary>
        </indexterm> on a <literal
      moreinfo="none">UniqueFilterIterator</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2466" significance="normal">
          <primary>UniqueFilterIterator</primary>
        </indexterm>, only objects not yet encountered are returned. The
      following example demonstrates the use of <literal
      moreinfo="none">UniqueFilterIterator</literal> to find unique elements
      in a <literal moreinfo="none">List</literal>:</para>

      <programlisting format="linespecific" id="I_5_tt213">import org.apache.commons.collections.iterators.UniqueFilterIterator;

String[] medals = new String[] { "gold", "silver", "silver", "gold", "bronze" };
List medalsList = Arrays.asList( medals );

Iterator uniqueIterator = new UniqueFilterIterator( medalsList.iterator( ) );

while( uniqueIterator.hasNext( ) ) {
    System.out.println( "Unique Medal: " + uniqueIterator.next( );
}</programlisting>

      <para><literal moreinfo="none">UniqueFilterIterator</literal> iterates
      over a <literal moreinfo="none">List</literal> of strings, returning one
      copy of each distinct element; <literal
      moreinfo="none">UniqueFilterIterator</literal> uses the <literal
      moreinfo="none">equals( )</literal> and <literal
      moreinfo="none">hashCode( )</literal> methods to compare objects in the
      <literal moreinfo="none">Collection</literal> passed to the constructor.
      Equal objects with equal hash codes are removed. As shown by the output
      produced by the example, the <literal
      moreinfo="none">UniqueFilterIterator</literal> prints out only the three
      distinct medals in the <literal moreinfo="none">medalsList</literal>:
      "gold," "silver," and "bronze":</para>

      <programlisting format="linespecific" id="I_5_tt214">Unique Medal: gold
Unique Medal: silver
Unique Medal: bronze</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>The building blocks for <literal
      moreinfo="none">UniqueFilterIterator</literal> have already been
      introduced. <literal moreinfo="none">FilterIterator</literal> was
      introduced in <link linkend="jakartackbk-CHP-5-SECT-4">Recipe
      5.4</link>, and <literal moreinfo="none">UniquePredicate</literal> is a
      <literal moreinfo="none">Predicate</literal> that keeps track of objects
      it has evaluated in a <literal moreinfo="none">HashSet</literal>. A
      <literal moreinfo="none">UniqueFilterIterator</literal> is the
      equivalent of a <literal moreinfo="none">FilterIterator</literal> with a
      <literal moreinfo="none">UniquePredicate</literal>. As the following
      code demonstrates, the example from the Solution can be implemented with
      a <literal moreinfo="none">FilterIterator</literal> and a <literal
      moreinfo="none">Predicate</literal>:</para>

      <programlisting format="linespecific" id="I_5_tt215">import org.apache.commons.collections.iterators.FilterIterator;
import org.apache.commons.collections.functors.UniquePredicate;

String[] medals = new String[] { "gold", "silver", "silver", "gold", "bronze" };
List medalsList = Arrays.asList( medals );

<userinput moreinfo="none">Iterator uniqueIterator = </userinput>
               <userinput moreinfo="none">    new FilterIterator( medalsList.iterator( ), new UniquePredicate( ) );</userinput>

while( uniqueIterator.hasNext( ) ) {
    System.out.println( "Unique Medal: " + uniqueIterator.next( );
}</programlisting>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>For more information about the <literal
      moreinfo="none">UniquePredicate</literal> see <link
      linkend="jakartackbk-CHP-4-SECT-7">Recipe 4.7</link>.</para>
    </sect2>
  </sect1>

  <sect1 id="collections-sect-bag" label="5.6" role="Recipe">
    <title>Using a Bag</title>

    <sect2>
      <title>Problem</title>

      <para>You need to find out how many times an<indexterm
          class="startofrange" id="jakartackbk-CHP-5-ITERM-2467"
          significance="normal">
          <primary>Commons Collections</primary>

          <secondary>bags</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2468" significance="normal">
          <primary>collections</primary>

          <secondary>bags</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2469" significance="normal">
          <primary>bags</primary>

          <secondary>collections</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2470" significance="normal">
          <primary>objects</primary>

          <secondary>Collections</secondary>

          <tertiary>bags</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2471" significance="normal">
          <primary>bags</primary>
        </indexterm> object occurs within a <literal
      moreinfo="none">Collection</literal>, and you need a <literal
      moreinfo="none">Collection</literal> that lets you manipulate the
      cardinality of objects it contains.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use a <literal moreinfo="none">Bag</literal>. A <literal
      moreinfo="none">Bag</literal> can store the same object multiple times
      while keeping track of how many copies it contains. For example, a
      <literal moreinfo="none">Bag</literal> object can contain 20 copies of
      object "A" and 50 copies of object "B," and it can be queried to see how
      many copies of an object it contains. You can also add or remove
      multiple copies of an object—add 10 copies of "A" or remove 4 copies of
      "B." The following example creates a <literal
      moreinfo="none">Bag</literal> and adds multiple copies of two <literal
      moreinfo="none">String</literal> objects:</para>

      <programlisting format="linespecific" id="I_5_tt216">import org.apache.commons.collections.Bag;
import org.apache.commons.collections.bag.HashBag;

Bag bag = new HashBag( );

bag.add( "TEST1", 100 );
bag.add( "TEST2", 500 );

int test1Count = bag.getCount( "TEST1" );
int test2Count = bag.getCount( "TEST2" );

System.out.println( "Counts: TEST1: " + test1Count + ", TEST2: " + test2Count );

bag.remove( "TEST1", 1 );
bag.remove( "TEST2", 10 );

int test1Count = bag.getCount( "TEST1" );
int test2Count = bag.getCount( "TEST2" );

System.out.println( "Counts: TEST1: " + test1Count + ", TEST2: " + test2Count );</programlisting>

      <para>This example put 100 copies of the <literal
      moreinfo="none">String</literal> "TEST1" and 500 copies of the <literal
      moreinfo="none">String</literal> "TEST2" into a <literal
      moreinfo="none">HashBag</literal>. The contents of the <literal
      moreinfo="none">Bag</literal> are then printed, and 1 instance of
      "TEST1" and 10 instances of "TEST2" are removed from the <literal
      moreinfo="none">Bag</literal>:</para>

      <programlisting format="linespecific" id="I_5_tt217">Counts: TEST1: 100, TEST2: 500
Counts: TEST1: 99, TEST2: 490</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para><literal moreinfo="none">Bag</literal> has two
      implementations—<literal moreinfo="none">HashBag</literal> and <literal
      moreinfo="none">TreeBag</literal>—which use a <literal
      moreinfo="none">HashMap</literal> and a <literal
      moreinfo="none">TreeMap</literal> to store the contents of a <literal
      moreinfo="none">Bag</literal>. The same design considerations apply to
      <literal moreinfo="none">Bag</literal> that apply to <literal
      moreinfo="none">Map</literal>. Use <literal
      moreinfo="none">HashBag</literal> for performance and <literal
      moreinfo="none">TreeBag</literal> when it is important to maintain the
      order that each distinct object was added to a <literal
      moreinfo="none">Bag</literal>. A <literal
      moreinfo="none">TreeBag</literal> returns unique objects in the order
      they were introduced to the <literal
      moreinfo="none">Bag</literal>.</para>

      <para>To demonstrate the <literal moreinfo="none">Bag</literal> object,
      a system to track inventory is created using a <literal
      moreinfo="none">Bag</literal> as an underlying data structure. An
      inventory management system must find out how many copies of a product
      are in stock, and a <literal moreinfo="none">Bag</literal> is
      appropriate because it allows you to keep track of the cardinality of an
      object in a <literal moreinfo="none">Collection</literal>. In <link
      linkend="jakartackbk-CHP-5-EX-3">Example 5-3</link>, a record store
      tracks an inventory of albums, consisting of 200 Radiohead albums, 100
      Kraftwerk albums, 500 Charlie Parker albums, and 900 ABBA albums.</para>

      <example id="jakartackbk-CHP-5-EX-3" label="5-3">
        <title>Using a Bag to track inventory</title>

        <programlisting format="linespecific">package com.discursive.jccook.collections.bag;

import java.text.NumberFormat;
import java.util.Collection;
import java.util.Iterator;
import java.util.Set;

import org.apache.commons.collections.Bag;
import org.apache.commons.collections.bag.HashBag;
import org.apache.commons.lang.StringUtils;

public class BagExample {
    Bag inventoryBag = new HashBag( );
    
    // Define 4 Albums
    Album album1 = new Album( "Radiohead", "OK Computer" );
    Album album2 = new Album( "Kraftwerk", "The Man-Machine" );
    Album album3 = new Album( "Charlie Parker", "Now's the Time" );
    Album album4 = new Album( "ABBA", "ABBA - Gold: Greatest Hits" );

    public static void main(String[] args) {
        BagExample example = new BagExample( );
        example.start( );
    }
    
    private void start( ) {
        // Read our inventory into a Bag
        populateInventory( );

        System.out.println( "Inventory before Transactions" );
        printAlbums( inventoryBag );
        printSeparator( );

        // A Customer wants to purchase 500 ABBA, 2 Radiohead, and 150 Parker
        Bag shoppingCart1 = new HashBag( );
        shoppingCart1.add( album4, 500 );
        shoppingCart1.add( album3, 150 );
        shoppingCart1.add( album1, 2 );
        checkout( shoppingCart1, "Customer 1" );
        
        // Another Customer wants to purchase 600 copies of ABBA 
        Bag shoppingCart2 = new HashBag( );
        shoppingCart2.add( album4, 600 );
        checkout( shoppingCart2, "Customer 2" );

        // Another Customer wants to purchase 3 copies of Kraftwerk
        Bag shoppingCart3 = new HashBag( );
        shoppingCart3.add( album2, 3 );
        checkout( shoppingCart3, "Customer 3" );

        System.out.println( "Inventory after Transactions" );
        printAlbums( inventoryBag );
        
    }
    
    private void populateInventory( ) {
        // Adds items to a Bag
        inventoryBag.add( album1, 200 );
        inventoryBag.add( album2, 100 );
        inventoryBag.add( album3, 500 );
        inventoryBag.add( album4, 900 );
    }
    
    private void printAlbums( Bag albumBag ) {
        Set albums = albumBag.uniqueSet( );
        Iterator albumIterator = albums.iterator( );
        while( albumIterator.hasNext( ) ) {
            Album album = (Album) albumIterator.next( );
            NumberFormat format = NumberFormat.getInstance( );
            format.setMinimumIntegerDigits( 3 );
            format.setMaximumFractionDigits( 0 );
            System.out.println( "\t" +  
                format.format( albumBag.getCount( album ) ) + 
                " - " + album.getBand( )  );
        }
    }
    
    private void checkout( Bag shoppingCart, String customer ) {
        // Check to see if we have the inventory to cover this purchase
        if( inventoryBag.containsAll( (Collection) shoppingCart ) ) {
            // Remove these items from our inventory
            inventoryBag.removeAll( (Collection) shoppingCart );
            System.out.println( customer + " purchased the following items:" );
            printAlbums( shoppingCart );
        } else {
            System.out.println( customer + ", I'm sorry " +
                                "but we are unable to fill your order." );
        }
        printSeparator( );
    }
    
    private void printSeparator( ) {
        System.out.println( StringUtils.repeat( "*", 65 ) );
    }
}</programlisting>
      </example>

      <para>Albums are stored in the <literal
      moreinfo="none">inventoryBag</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2472" significance="normal">
          <primary>inventoryBag variable</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2473"
          significance="normal">
          <primary>variables</primary>

          <secondary>inventoryBag</secondary>
        </indexterm> variable, which is populated by a call to <literal
      moreinfo="none">populateInventory()</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2474" significance="normal">
          <primary>populateInventory( ) method</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2475"
          significance="normal">
          <primary>methods</primary>

          <secondary>populateInventory( )</secondary>
        </indexterm> method. The <literal
      moreinfo="none">printAlbums()</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2476" significance="normal">
          <primary>printAlbums( ) method</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2477"
          significance="normal">
          <primary>methods</primary>

          <secondary>printAlbums( )</secondary>
        </indexterm> method demonstrates how a <literal
      moreinfo="none">Bag</literal>'s iterator will iterate through all of the
      distinct objects stored in a <literal moreinfo="none">Bag</literal>,
      printing out the count for each album by calling <literal
      moreinfo="none">getCount( )</literal> on the <literal
      moreinfo="none">inventoryBag</literal>. After populating and printing
      the store's inventory, the<indexterm id="jakartackbk-CHP-5-ITERM-2478"
          significance="normal">
          <primary>start( ) method</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2479"
          significance="normal">
          <primary>methods</primary>

          <secondary>start( )</secondary>
        </indexterm> <literal moreinfo="none">start( )</literal> method models
      the behavior of three customers. Each customer creates a <literal
      moreinfo="none">Bag</literal> instance, <literal
      moreinfo="none">shoppingBag</literal>, which holds the <literal
      moreinfo="none">Album</literal> objects she wishes to purchase.</para>

      <para>When a customer checks out of the store, the <literal
      moreinfo="none">containsAll()</literal> method is called to make sure
      that the <literal moreinfo="none">inventoryBag</literal> contains
      adequate inventory to fulfill a customer's order. If a customer attempts
      to buy 40 copies of an album, we create a <literal
      moreinfo="none">Bag</literal> with 40 instances of the <literal
      moreinfo="none">Album</literal> object, and <literal
      moreinfo="none">containsAll( )</literal> will only return <literal
      moreinfo="none">true</literal> if the <literal
      moreinfo="none">inventoryBag</literal> contains at least 40 matching
      albums. Certain that the order can be fulfilled, <literal
      moreinfo="none">removeAll( )</literal> reduces the number of albums in
      the <literal moreinfo="none">inventoryBag</literal> by 40 and the
      customer's transaction is considered complete.</para>

      <para>Each customer transaction is modeled by a <literal
      moreinfo="none">Bag</literal> that is subtracted from the <literal
      moreinfo="none">inventoryBag</literal> using the <literal
      moreinfo="none">removeAll( )</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2480" significance="normal">
          <primary>removeAll( ) method</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2481"
          significance="normal">
          <primary>methods</primary>

          <secondary>removeAll( )</secondary>
        </indexterm>method. <link linkend="jakartackbk-CHP-5-EX-3">Example
      5-3</link> prints the inventory before and after the three customer
      transactions, summarizing the result of each:</para>

      <programlisting format="linespecific" id="I_5_tt218">Inventory before Transactions
    200 - Radiohead
    100 - Kraftwerk
    900 - ABBA
    500 - Charlie Parker
*****************************************************************
Customer 1 purchased the following items:
    002 - Radiohead
    500 - ABBA
    150 - Charlie Parker
*****************************************************************
Customer 2, I'm sorry but we are unable to fill your order.
*****************************************************************
Customer 3 purchased the following items:
    003 - Kraftwerk
*****************************************************************
Inventory after Transactions
    198 - Radiohead
    097 - Kraftwerk
    400 - ABBA
    350 - Charlie Parker</programlisting>

      <para>Technically speaking, <literal moreinfo="none">Bag</literal> is
      not a real <literal moreinfo="none">Collection</literal> implementation.
      The <literal moreinfo="none">removeAll( )</literal>, <literal
      moreinfo="none">containsAll( )</literal>, <literal
      moreinfo="none">add()</literal>, <literal moreinfo="none">remove(
      )</literal>, and <literal moreinfo="none">retainAll( )</literal> methods
      do not strictly follow the contract defined by the <literal
      moreinfo="none">Collection</literal> interface. Adhering to a strict
      interpretation of the <literal moreinfo="none">Collection</literal>
      interface, <literal moreinfo="none">removeAll( )</literal> should remove
      all traces of an object from a collection, and <literal
      moreinfo="none">containsAll( )</literal> should not pay attention to the
      cardinality of an object in a collection. Calling <literal
      moreinfo="none">removeAll( )</literal> with a single <literal
      moreinfo="none">Album</literal> object should clear the <literal
      moreinfo="none">Bag</literal> of any references to the specified
      <literal moreinfo="none">Album</literal> object, and <literal
      moreinfo="none">containsAll( )</literal> should return <literal
      moreinfo="none">true</literal> if a collection contains even one
      instance of a specified object. In <literal
      moreinfo="none">Bag</literal>, a call to <literal
      moreinfo="none">removeAll( )</literal> with three <literal
      moreinfo="none">Album</literal> objects will remove only the specified
      number of each <literal moreinfo="none">Album</literal> object. In <link
      linkend="jakartackbk-CHP-5-EX-3">Example 5-3</link>, the <literal
      moreinfo="none">checkout( )</literal> method uses <literal
      moreinfo="none">removeAll( )</literal> to remove albums from the
      inventory. A call to <literal moreinfo="none">containsAll( )</literal>
      will only return <literal moreinfo="none">true</literal> if a <literal
      moreinfo="none">Bag</literal> contains a number greater than or equal to
      the cardinality specified in the <literal
      moreinfo="none">Collection</literal>. In <link
      linkend="jakartackbk-CHP-5-EX-3">Example 5-3</link>, the <literal
      moreinfo="none">checkout( )</literal> method uses <literal
      moreinfo="none">containsAll( )</literal> to see if there is sufficient
      inventory to satisfy an order. These violations should not keep you from
      using <literal moreinfo="none">Bag</literal>, but keep these exceptions
      to the collection interface in mind if you are going to expose a
      <literal moreinfo="none">Bag</literal> as a collection in a widely used
      API.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>For more information about the bag <indexterm class="endofrange"
      id="jakartackbk-CHP-5-ITERM-2482" significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2467"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2483"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2468"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2484"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2469"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2485"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2470"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2486"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2471"></indexterm>data structure, look
      at a definition from the <indexterm id="jakartackbk-CHP-5-ITERM-2487"
          significance="normal">
          <primary>National Institute of Standards and Technology
          (NIST)</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2488"
          significance="normal">
          <primary>NIST (National Institute of Standards and
          Technology)</primary>
        </indexterm>National Institute of Standards and Technology (NIST) at
      <systemitem moreinfo="none"
      role="url">http://www.nist.gov/dads/HTML/bag.html</systemitem>.</para>
    </sect2>
  </sect1>

  <sect1 id="collections-using-buffer" label="5.7" role="Recipe">
    <title>Using a Buffer</title>

    <sect2>
      <title>Problem</title>

      <para>You need a data structure that can<indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2489" significance="normal">
          <primary>Commons Collections</primary>

          <secondary>buffers</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2490" significance="normal">
          <primary>collections</primary>

          <secondary>buffers</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2491" significance="normal">
          <primary>buffers</primary>

          <secondary>collections</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2492" significance="normal">
          <primary>objects</primary>

          <secondary>Collections</secondary>

          <tertiary>buffers</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2493" significance="normal">
          <primary>buffers</primary>
        </indexterm> act as a temporary staging area, i.e., a buffer.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">Buffer</literal> from Jakarta Commons
      Collections. A <firstterm>buffer</firstterm> is an object that is
      defined by the algorithm used for element removal. <literal
      moreinfo="none">Buffer</literal> objects can be priority queues, staging
      areas, message queues, or buffers for I/O. One of the simplest <literal
      moreinfo="none">Buffer</literal> implementations is the <literal
      moreinfo="none">UnboundedFifoBuffer</literal>, a first-in, first-out
      data structure with no size limit. The following example demonstrates
      the use of an <literal
      moreinfo="none">UnboundedFifoBuffer</literal>:</para>

      <programlisting format="linespecific" id="I_5_tt219">import org.apache.commons.collections.Buffer;
import org.apache.commons.collections.buffer.UnboundedFifoBuffer;

// Create an Unbounded FIFO
Buffer buffer = new UnboundedFifoBuffer( );

// Add elements to the Buffer
buffer.add("A");
buffer.add("B");
buffer.add("D");

// Remove element from the buffer
String value = (String) buffer.remove( );

buffer.add("E");

value = (String) buffer.remove( );</programlisting>

      <para>This example creates an <literal
      moreinfo="none">UnboundedFifoBuffer</literal>, adding three elements:
      "A," "B," and "D." When <literal moreinfo="none">remove()</literal> is
      invoked, the buffer selects the item that was placed into the buffer
      first—the first-in is the first-out. The first call to <literal
      moreinfo="none">remove( )</literal> returns "A," and the second call
      returns "B."</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>A FIFO buffer can be viewed as a kind of stack; instead of
      <literal moreinfo="none">pop( )</literal> returning the last item to be
      placed on the stack, <literal moreinfo="none">remove( )</literal>
      returns the bottom of the stack—the first item added to the <literal
      moreinfo="none">Buffer</literal>. A <literal
      moreinfo="none">Buffer</literal> throws a <literal
      moreinfo="none">BufferUnderflowException</literal> if you try to
      <literal moreinfo="none">remove( )</literal> or <literal
      moreinfo="none">get( )</literal> an element from an empty <literal
      moreinfo="none">Buffer</literal>. This data structure is useful if you
      need a temporary holding area between stages in a pipeline—a queue to
      hold objects as they wait to be processed by the next stage. An
      unbounded<indexterm id="jakartackbk-CHP-5-ITERM-2494"
          significance="normal">
          <primary>FIFO buffers</primary>
        </indexterm> FIFO buffer has no size limit, and, as such, it could
      grow to a limitless size. In fact, if an application continued to fill
      an unbounded buffer, it would exhaust available memory. <link
      linkend="jakartackbk-CHP-5-FIG-1">Figure 5-1</link> describes a FIFO
      buffer as a linear sequence of elements: items flow through this
      sequence from left to right.</para>

      <figure float="0" id="jakartackbk-CHP-5-FIG-1" label="5-1">
        <title>A FIFO buffer</title>

        <mediaobject id="I_5_tt220">
          <imageobject role="print">
            <imagedata depth="30" fileref="figs/print/jccb_0501.pdf"
                       format="PDF" width="181" />
          </imageobject>

          <imageobject role="web">
            <imagedata depth="30" fileref="figs/web/jccb_0501.png"
                       format="PNG" width="181" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>In addition to <literal
      moreinfo="none">UnboundedFifoBuffer</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2495" significance="normal">
          <primary>UnboundedFifoBuffer</primary>
        </indexterm>, there is a bounded counterpart—<literal
      moreinfo="none">BoundedFifoBuffer</literal>. <literal
      moreinfo="none">BoundedFifoBuffer</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2496" significance="normal">
          <primary>BoundedFifoBuffer</primary>
        </indexterm> has a maximum size that cannot be exceeded; adding an
      object to a <literal moreinfo="none">BoundedFifoBuffer</literal> already
      at maximum size will cause a <literal
      moreinfo="none">BufferOverflowException</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2497" significance="normal">
          <primary>BufferOverflowException</primary>
        </indexterm>. <link linkend="jakartackbk-CHP-5-EX-4">Example
      5-4</link> demonstrates the use of a bounded buffer with a maximum size
      limit of two.</para>

      <example id="jakartackbk-CHP-5-EX-4" label="5-4">
        <title>Using a BoundedFifoBuffer</title>

        <programlisting format="linespecific">import org.apache.commons.collections.Buffer;
import org.apache.commons.collections.BufferOverflowException;
import org.apache.commons.collections.buffer.BoundedFifoBuffer;
...

<userinput moreinfo="none">// Create a Bounded FIFO with a max size of two</userinput>
                  <userinput moreinfo="none">Buffer buffer = new BoundedFifoBuffer(2);</userinput>

buffer.add( "One" );
buffer.add( "Two" );

// Adding a third element to this buffer will cause an exception
try {
    buffer.add( "Three" );
} catch( BufferOverflowException bue ) {
    System.out.println( "Buffer is Full!" );
}

// Remove an object... Buffer now contains one element.
Object removed = buffer.remove( );

// Add another object
buffer.add( "Three" );

Object remove1 = buffer.remove( );
Object remove2 = buffer.remove( );

// This next remove( ) should cause a BufferUnderflowException
try {
    Object remove3 = buffer.remove( );
} catch( BufferUnderflowException bue ) {
    System.out.println( "Buffer is Empty!" );
}</programlisting>
      </example>

      <tip id="jakartackbk-CHP-5-NOTE-57" role="ora">
        <para>Later recipes will demonstrate the use of <literal
        moreinfo="none">Buffer</literal> objects in processing pipelines where
        it is important to provide a limit on how much memory a <literal
        moreinfo="none">Buffer</literal> is able to consume.</para>
      </tip>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>A <literal moreinfo="none">Buffer</literal> in Jakarta Commons
      Collections is analogous to a <literal moreinfo="none">Queue</literal>
      in Java 5.0. The <literal moreinfo="none">Queue</literal> interface is
      accompanied by a number of interfaces that provide almost identical
      behavior to the <literal moreinfo="none">Buffer</literal> interface as
      defined in Jakarta Commons Collections 3.0. <literal
      moreinfo="none">Queue</literal> contains some new methods, <literal
      moreinfo="none">offer( )</literal> and <literal moreinfo="none">peek(
      )</literal>, which perform the same functions as <literal
      moreinfo="none">add( )</literal> and <literal moreinfo="none">remove(
      )</literal>, with one difference: these new methods return <literal
      moreinfo="none">false</literal> if there is any problem adding an object
      to a <literal moreinfo="none">Queue</literal>. More information about
      queues and other changes to the Collections framework in Java 5.0
      <indexterm class="endofrange" id="jakartackbk-CHP-5-ITERM-2498"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2489"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2499"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2490"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2500"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2491"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2501"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2492"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2502"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2493"></indexterm>are available at:
      <systemitem moreinfo="none"
      role="url">http://java.sun.com/j2se/1.5.0/docs/guide/collections/changes5.html</systemitem>.</para>
    </sect2>
  </sect1>

  <sect1 id="collections-sect-priority-q" label="5.8" role="Recipe">
    <title>Creating a Priority Queue</title>

    <sect2>
      <title>Problem</title>

      <para>You need to prioritize<indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2503" significance="normal">
          <primary>Commons Collections</primary>

          <secondary>priority queues</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2504" significance="normal">
          <primary>collections</primary>

          <secondary>priority queues</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2505" significance="normal">
          <primary>objects</primary>

          <secondary>Collections</secondary>

          <tertiary>priority queues</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2506" significance="normal">
          <primary>priority queues</primary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2507" significance="normal">
          <primary>queues, priority</primary>
        </indexterm> objects: removing higher priority objects from a <literal
      moreinfo="none">Collection</literal> before lower priority
      objects.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use a <literal moreinfo="none">PriorityBuffer</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2508" significance="normal">
          <primary>PriorityBuffer</primary>
        </indexterm> to hold objects to be prioritized. Objects will be
      removed from this <literal moreinfo="none">Buffer</literal> according to
      a priority generated with a <literal
      moreinfo="none">Comparator</literal>. Whenever the <literal
      moreinfo="none">remove( )</literal> method is called on this <literal
      moreinfo="none">Buffer</literal> implementation, a <literal
      moreinfo="none">PriorityBuffer</literal> uses the <literal
      moreinfo="none">Comparator</literal> to sort its contents, returning the
      element of greatest priority. Using a <literal
      moreinfo="none">PriorityBuffer</literal> without a <literal
      moreinfo="none">Comparator</literal> causes the buffer to prioritize
      objects by natural order, casting each object to <literal
      moreinfo="none">Comparable</literal> and comparing objects with the
      <literal moreinfo="none">compareTo( )</literal> method; all objects must
      implement the <literal moreinfo="none">Comparable</literal> interface if
      no <literal moreinfo="none">Comparator</literal> is supplied. The
      following example demonstrates the use of a <literal
      moreinfo="none">PriorityBuffer</literal> without supplying a <literal
      moreinfo="none">Comparator</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2509" significance="normal">
          <primary>Comparators</primary>

          <secondary>PriorityBuffer</secondary>
        </indexterm>:</para>

      <programlisting format="linespecific" id="I_5_tt221">import java.util.*;
import org.apache.commons.collections.Buffer;
import org.apache.commons.collections.buffers.PriorityBuffer;

// Create a PriorityBuffer with no Comparator
Buffer priority = new PriortyBuffer( );
priority.add( new Long( 2 ) );
priority.add( new Long( 1 ) );
priority.add( new Long( 20 ) );
priority.add( new Long( 7 ) );
priority.add( new Long( 18 ) );
priority.add( new Long( 1 ) );

// Print the results in priority order
Iterator priorityIterator = priority.iterator( );
while( priorityIterator.hasNext( ) ) {
    Long value = (Long) priority.next( );
    System.out.prinltn( "Value: " + value );
}</programlisting>

      <para>The previous example removes values from the buffer based on a
      natural order, and the following output is produced:</para>

      <programlisting format="linespecific" id="I_5_tt222">Value: 20
Value: 18
Value: 7
Value: 2
Value: 1
Value: 1</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>A <literal moreinfo="none">PriorityBuffer</literal>, like all
      <literal moreinfo="none">Buffer</literal> implementations, is defined by
      the logic to select which object to remove. If you've ever visited an
      emergency room, you are already familiar with the inner workings of the
      <literal moreinfo="none">PriorityBuffer</literal>. When a patient enters
      the emergency room, his or her condition is evaluated by a nurse who
      then assigns a severity. When a doctor moves to the next patient, she
      chooses the next patient based on severity and how long each patient has
      been waiting. A patient with a critical, life-threatening condition will
      be treated before an individual with a headache—the critical patient has
      a higher priority in the <literal
      moreinfo="none">Buffer</literal>.</para>

      <para>The following example models an emergency waiting room with a
      <literal moreinfo="none">PriorityBuffer</literal>. Assume that you have
      a <literal moreinfo="none">Patient</literal> bean with <literal
      moreinfo="none">name</literal>, <literal
      moreinfo="none">severity</literal>, and <literal
      moreinfo="none">checkIn</literal> properties, which is defined in <link
      linkend="jakartackbk-CHP-5-EX-5">Example 5-5</link>. A patient's
      severity is a number from 0 to 10, 0 being the lowest severity and 10
      being the highest. A critical patient would be assigned a priority of
      10, and a patient with a bad cold would be assigned a severity of 0. A
      patient also has a <literal moreinfo="none">checkIn</literal> time: this
      is the time he is admitted to the waiting room, and it is used as a
      tie-breaker to determine priority when two patients have the same
      <literal moreinfo="none">severity</literal>.</para>

      <example id="jakartackbk-CHP-5-EX-5" label="5-5">
        <title>A Patient object</title>

        <programlisting format="linespecific">package com.discursive.jccook.collections.buffers;

public class Patient {
    private String name;
    private Integer severity;
    private Date checkIn;

    public class Patient( ) {}

    public String getName( ) { return name; }
    public void setName(String name) { this.name = name; }

    public Integer getSeverity( ) { return severity; }
    public void setSeverity(Integer severity) { this.severity = severity; }

    public Date getCheckIn( ) { return checkIn; }
    public void setCheckIn(Date checkIn) { this.checkIn = checkIn; }
}</programlisting>
      </example>

      <para>The <literal moreinfo="none">PatientPriorityComparator</literal>
      <indexterm id="jakartackbk-CHP-5-ITERM-2510" significance="normal">
          <primary>PatientPriorityComparator</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2511"
          significance="normal">
          <primary>Comparators</primary>

          <secondary>PatientPriorityComparator</secondary>
        </indexterm>in <link linkend="jakartackbk-CHP-5-EX-6">Example
      5-6</link> prioritizes patients by severity of condition and time since
      check-in. A patient with a more severe condition takes priority over a
      patient with a less severe condition who has been waiting longer, and,
      if two patients have the same severity, the one who has been waiting
      longer gets a higher priority. If this <literal
      moreinfo="none">Comparator</literal> is used to sort an array of
      <literal moreinfo="none">Patient</literal> objects, the most critical
      patient would be at the last index, and the least critical would be at
      the first index.</para>

      <example id="jakartackbk-CHP-5-EX-6" label="5-6">
        <title>A Comparator to sort Patient objects by priority</title>

        <programlisting format="linespecific">package com.discursive.jccook.collections.buffers;

import java.util.Comparator;

public PatientPriorityComparator implements Comparator {

    public int compare(Object o1, Object o2) {
        int comparison = -1;

        if( o1 instanceof Patient &amp;&amp;
            o2 instanceof Patient ) {

            Patient p1 = (Patient) o1;
            Patient p2 = (Patient) o2;

            comparison = p1.getSeverity( ).compareTo( p2.getSeverity( ) );

                if( comparison == 0 ) {
                    comparison = 
                    p1.getCheckIn( ).compareTo( p2.getCheckIn( ) );
            }
        }
        return comparison;
    }
}</programlisting>
      </example>

      <para>When using the <literal moreinfo="none">PriorityBuffer</literal>
      with a <literal moreinfo="none">PatientPriorityComparator</literal>,
      <literal moreinfo="none">Patient</literal> objects are added to the
      <literal moreinfo="none">Buffer</literal> and <literal
      moreinfo="none">remove( )</literal> returns the <literal
      moreinfo="none">Patient</literal> with the highest priority. Using a
      <literal moreinfo="none">PriorityBuffer</literal> means that you do not
      need to worry about constantly resorting a <literal
      moreinfo="none">Collection</literal> by priority; this logic is
      completed automatically every time an object is removed from the
      <literal moreinfo="none">Buffer</literal>. In other words, you are
      delegating responsibility to a <literal
      moreinfo="none">Buffer</literal>; it takes care of the sorting and
      selecting on an as-needed basis.</para>

      <para><link linkend="jakartackbk-CHP-5-EX-7">Example 5-7</link> adds
      three <literal moreinfo="none">Patient</literal> objects to a <literal
      moreinfo="none">PriorityBuffer</literal>: John Doe 1 has an ear ache,
      John Doe 2 has a broken back, and Jane Doe 3 has a concussion. Both John
      2 and Jane 3 have serious conditions, and, since John 2 checked in
      before Jane 3, John 2 has a higher priority than Jane 3. John 1's
      condition is not nearly as critical; therefore, his priority is much
      lower, and he is treated last.</para>

      <example id="jakartackbk-CHP-5-EX-7" label="5-7">
        <title>Using a prioritizing buffer</title>

        <programlisting format="linespecific">package com.discursive.jccook.collections.buffers;

public class WaitingRoomApp {

    public static void main(String[] args) {
        WaitingRoomApp example = new WaitingRoomApp( );
        example.start( );
    }

    public void start( ) {
        Buffer patients = 
            new PriorityBuffer( new PatientPriorityComparator( ) );

        Patient johnDoe1 = new Patient( );
        johnDoe1.setName( "John Doe 1" );
        johnDoe1.setSeverity( new Integer( 7 ) );
        johnDoe1.setCheckIn( new Date( ) );
        patients.add( johnDoe1 );

        Patient johnDoe2 = new Patient( );
        johnDoe2.setName( "John Doe 2" );
        johnDoe2.setSeverity( new Integer( 9 ) );
        johnDoe2.setCheckIn( new Date( ) );
        patients.add( johnDoe2 );

        Patient janeDoe3 = new Patient( );
        janeDoe3.setName( "Jane Doe 3" );
        janeDoe3.setSeverity( new Integer( 9 ) );
        janeDoe3.setCheckIn( new Date( ) );
        patients.add( janeDoe3 );

         while( patients.size( ) &gt; 0 ) {
            Patient patient = (Patient) patients.remove( );
            System.out.println( "Patient: " + patient.getName( ) );
        }
    }
}</programlisting>
      </example>

      <para>As each <literal moreinfo="none">Patient</literal> is treated, the
      patient's name is printed to the console:</para>

      <programlisting format="linespecific" id="I_5_tt223">Patient: John Doe 2
Patient: Jane Doe 3
Patient: John Doe 1</programlisting>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>A <literal moreinfo="none">PriorityBuffer</literal> in Jakarta
      <indexterm class="endofrange" id="jakartackbk-CHP-5-ITERM-2512"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2503"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2513"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2504"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2514"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2505"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2515"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2506"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2516"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2507"></indexterm>Commons Collections
      is analogous to a <literal moreinfo="none">PriorityQueue</literal> in
      Java 5.0. For information about <literal
      moreinfo="none">PriorityQueue</literal> and other important changes to
      the Collections framework in Java 5.0, see <systemitem moreinfo="none"
      role="url">http://java.sun.com/j2se/1.5.0/docs/api/index.html</systemitem>.</para>
    </sect2>
  </sect1>

  <sect1 id="collections-sect-blocking" label="5.9" role="Recipe">
    <title>Using a Blocking Buffer</title>

    <sect2>
      <title>Problem</title>

      <para>Your system needs to wait<indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2517" significance="normal">
          <primary>Commons Collections</primary>

          <secondary>blocking buffers</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2518" significance="normal">
          <primary>collections</primary>

          <secondary>blocking buffers</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2519" significance="normal">
          <primary>blocking buffers, collections</primary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2520" significance="normal">
          <primary>objects</primary>

          <secondary>Collections</secondary>

          <tertiary>blocking buffers</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2521" significance="normal">
          <primary>buffers</primary>

          <secondary>blocking</secondary>
        </indexterm> for input and act on an object the moment it is added to
      a <literal moreinfo="none">Buffer</literal>. To achieve this, you need
      your application to block until input is received.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">BlockingBuffer</literal> to decorate
      an instance of <literal moreinfo="none">Buffer</literal>. When a process
      calls <literal moreinfo="none">get( )</literal> or <literal
      moreinfo="none">remove( )</literal> on a buffer decorated with <literal
      moreinfo="none">BlockingBuffer</literal>, the decorated buffer does not
      return a value until it has an object to return. The following example
      creates a <literal moreinfo="none">BlockingBuffer</literal> and a
      listener that calls <literal moreinfo="none">remove( )</literal>. A
      <literal moreinfo="none">BlockingBuffer</literal> can only be
      demonstrated by an example that deals with multiple threads, and the
      following code uses a <literal moreinfo="none">Runnable</literal>
      implementation, <literal moreinfo="none">BufferListener</literal>, which
      is defined in <link linkend="jakartackbk-CHP-5-EX-8">Example
      5-8</link>:</para>

      <programlisting format="linespecific" id="I_5_tt224">import java.util.*;
import org.apache.commons.collections.Buffer;
import org.apache.commons.collections.buffers.BlockingBuffer;
import org.apache.commons.collections.buffers.BoundedFifoBuffer;

<emphasis role="bold">// Create a Blocking Buffer</emphasis>
Buffer buffer = BlockingBuffer.decorate( new BoundedFifoBuffer( ) );

<userinput moreinfo="none">// Create Thread to continously remove( ) from the previous Buffer</userinput>
               <userinput moreinfo="none">BufferListener listener = new BufferListener(buffer);</userinput>
Thread listenerThread = new Thread( listener );
listenerThread.start( );

buffer.add( "Hello World!" );
buffer.add( "Goodbye, Y'all." );</programlisting>

      <para>The previous example creates an instance of <literal
      moreinfo="none">BufferListener</literal>—a <literal
      moreinfo="none">Runnable</literal> object that calls <literal
      moreinfo="none">remove( )</literal> on a <literal
      moreinfo="none">BoundedFifoBuffer</literal> decorated with <literal
      moreinfo="none">BlockingBuffer</literal>. The <literal
      moreinfo="none">listenerThread</literal> will block on a call to
      <literal moreinfo="none">buffer.remove( )</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2522" significance="normal">
          <primary>buffer.remove( ) method</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2523"
          significance="normal">
          <primary>methods</primary>

          <secondary>buffer.remove( )</secondary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2524"
          significance="normal">
          <primary>remove( ) method</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2525"
          significance="normal">
          <primary>methods</primary>

          <secondary>remove( )</secondary>
        </indexterm> within the <literal moreinfo="none">run( )</literal>
      method of <literal moreinfo="none">BufferListener</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2526" significance="normal">
          <primary>BufferListener</primary>
        </indexterm>, an object that runs in a separate thread and waits for
      objects to be added to a <literal
      moreinfo="none">BlockingBuffer</literal>.</para>

      <example id="jakartackbk-CHP-5-EX-8" label="5-8">
        <title>A BufferListener constantly calling remove( )</title>

        <programlisting format="linespecific">public class BufferListener implements Runnable {
    private Buffer buffer;

    public BufferListener(Buffer buffer) {
        this.buffer = buffer;
    }

    public void run( ) {
        while(true) {
<userinput moreinfo="none">            String message = (String) buffer.remove( );</userinput>
            System.out.println( message );
        }
    }
}</programlisting>
      </example>

      <para>The two calls to <literal moreinfo="none">buffer.add( )</literal>
      causes <literal moreinfo="none">BufferListener</literal> to print the
      strings added:</para>

      <programlisting format="linespecific" id="I_5_tt225">Hello World!
Goodbye, Y'all.</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>A <literal moreinfo="none">BlockingBuffer</literal> is used in a
      system that needs to act on a piece a data as soon as it is available,
      and this data structure comes in handy when there are a series of worker
      threads listening to buffers between components in a pipeline. <literal
      moreinfo="none">BlockingBuffer</literal> allows you to build cascading
      pipelines, which automatically notify the next stage of available data.
      Think of this pattern as a stepped waterfall; water automatically flows
      down the steps, and each step is a <literal
      moreinfo="none">Buffer</literal>. (See <link
      linkend="jakartackbk-CHP-5-FIG-2">Figure 5-2</link>.)</para>

      <figure float="0" id="jakartackbk-CHP-5-FIG-2" label="5-2">
        <title>Using a BlockingBuffer to create a pipeline</title>

        <mediaobject id="I_5_tt226">
          <imageobject role="print">
            <imagedata depth="56" fileref="figs/print/jccb_0502.pdf"
                       format="PDF" width="310" />
          </imageobject>

          <imageobject role="web">
            <imagedata depth="56" fileref="figs/web/jccb_0502.png"
                       format="PNG" width="310" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Assume that you need to write a workflow application for a news
      publisher; the workflow consists of a pipeline: news stories are
      published as XML files, which are passed to a search indexer and then
      processed with an XSLT stylesheet. A news story is simply passed as a
      <literal moreinfo="none">String</literal> containing an XML document.
      The following example creates a pipeline consisting of two <literal
      moreinfo="none">BlockingBuffer</literal> instances terminated by an
      <literal moreinfo="none">UnboundedFifoBuffer</literal>:</para>

      <programlisting format="linespecific" id="I_5_tt227">import java.util.*;
import org.apache.commons.collections.Buffer;
import org.apache.commons.collections.buffers.BlockingBuffer;
import org.apache.commons.collections.buffers.UnboundedFifoBuffer;

<emphasis role="bold">// Create a Blocking Buffer for each stage, last stage not a blocking buffer</emphasis>
Buffer published = BlockingBuffer.decorate( new UnboundedFifoBuffer( ) );
Buffer indexed = BlockingBuffer.decorate( new UnboundedFifoBuffer( ) );
Buffer transformed = new UnboundedFifoBuffer( );

<emphasis role="bold">// Create a Thread that will watch the published Buffer and index a news story</emphasis>
Indexer indexer = new Indexer(published, indexed);
Thread indexerThread = new Thread( indexer );
indexerThread.start( );

<emphasis role="bold">// Create a Thread that will watch the indexed Buffer and style a news story</emphasis>
Styler styler = new Styler(index, transformed);
Thread stylerThread = new Thread( styler );
stylerThread.start( );

String newsStory = getNewsStory( );

published.add( newsStory );</programlisting>

      <para>The previous example creates three buffers to hold the results of
      the stages of a pipeline—<literal moreinfo="none">published</literal>,
      <literal moreinfo="none">indexed</literal>, and <literal
      moreinfo="none">transformed</literal>. Three <literal
      moreinfo="none">Runnable</literal> objects are created to perform the
      task of processing each news story; the <literal
      moreinfo="none">Indexer</literal> object listens to the <literal
      moreinfo="none">published</literal> buffer and places its results in the
      <literal moreinfo="none">indexed</literal> buffer, and the <literal
      moreinfo="none">Styler</literal> object listens to the <literal
      moreinfo="none">indexed</literal> buffer and places its results in the
      <indexterm id="jakartackbk-CHP-5-ITERM-2527" significance="normal">
          <primary>indexes</primary>

          <secondary>buffer</secondary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2528"
          significance="normal">
          <primary>buffers</primary>

          <secondary>indexes</secondary>
        </indexterm> <literal moreinfo="none">transformed</literal> buffer.
      The <literal moreinfo="none">Indexer</literal> object implements
      <literal moreinfo="none">Runnable</literal> and is constructed with two
      <literal moreinfo="none">Buffer</literal> objects, <literal
      moreinfo="none">inbound</literal> and <literal
      moreinfo="none">outbound</literal>. The <literal
      moreinfo="none">Indexer</literal>, as shown in <link
      linkend="jakartackbk-CHP-5-EX-9">Example 5-9</link>, continuously calls
      <literal moreinfo="none">remove( )</literal> on a <literal
      moreinfo="none">BlockingBuffer</literal> and waits until a story is
      available to process.</para>

      <example id="jakartackbk-CHP-5-EX-9" label="5-9">
        <title>An Indexer stage in a pipeline</title>

        <programlisting format="linespecific">public class Indexer implements Runnnable {
    private Buffer inbound;
    private Buffer outbound;

    public Indexer(Buffer inbound, Buffer outbound) {
        this.inbound = inbound;
        this.outbound = outbound;
    }

    public void run( ) {
        while(true) {
            String story = (String) inbound.remove( );
                String processedStory = processStory( story );
            outbound.add( processedStory );
        }
    }

    public String processedStory(String story) {
        // Run story through a search indexer
        return story;
    }
}</programlisting>
      </example>

      <para>The <literal moreinfo="none">Styler</literal> is omitted because
      it follows the exact same pattern. Every stage in this pipeline is a
      <literal moreinfo="none">Runnable</literal> implementation running in a
      thread and listening to an inbound buffer by calling (and blocking) on
      <literal moreinfo="none">inbound.remove( )</literal>. Using this
      mechanism allows your system to process information in parallel by
      running separate stages in separate threads, and there is no need for a
      controller to coordinate the actions of a complex system. A pipeline can
      be extended by simply adding another stage with an additional <literal
      moreinfo="none">BlockingBuffer</literal>. This pattern is useful in a
      system that models a very complex workflow; instead of attempting to
      capture a complex symphony of coordination, break the system into
      autonomous stages that only know about inputs and outputs.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>A <literal moreinfo="none">BlockingBuffer</literal> in Jakarta
      Commons Collections is analogous to a <literal
      moreinfo="none">BlockingQueue</literal> in Java 5.0. A <literal
      moreinfo="none">BlockingQueue</literal> in Java 5.0 has an important
      feature that is missing in Commons Collections 3.0 implementation of
      <literal moreinfo="none">BlockingBuffer</literal>: in Java 5.0's
      <literal moreinfo="none">BlockingQueue</literal>, you can specify a
      timeout when adding and <indexterm class="endofrange"
      id="jakartackbk-CHP-5-ITERM-2529" significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2517"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2530"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2518"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2531"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2519"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2532"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2520"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2533"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2521"></indexterm>removing values from
      a queue.</para>
    </sect2>
  </sect1>

  <sect1 id="collections-sect-multi-map" label="5.10" role="Recipe">
    <title>Storing Multiple Values in a Map</title>

    <sect2>
      <title>Problem</title>

      <para>You need to store multiple <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2534" significance="normal">
          <primary>Commons Collections</primary>

          <secondary>multiple value storage</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2535" significance="normal">
          <primary>collections</primary>

          <secondary>multiple value storage</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2536" significance="normal">
          <primary>multiple value storage</primary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2537" significance="normal">
          <primary>objects</primary>

          <secondary>Collections</secondary>

          <tertiary>multiple value storage</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2538" significance="normal">
          <primary>mapping</primary>

          <secondary>multiple value storage</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2539" significance="normal">
          <primary>values</primary>

          <secondary>multiple value storage</secondary>
        </indexterm>values for a single key in a <literal
      moreinfo="none">Map</literal>. Instead of a one-to-one relationship
      between keys and values, you need a <literal
      moreinfo="none">Map</literal> that provides one-to-many relationships
      between keys and values.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use a <literal moreinfo="none">MultiMap</literal>. A <literal
      moreinfo="none">MultiMap</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2540" significance="normal">
          <primary>MultiMap</primary>
        </indexterm> maintains a collection of values for a given key. When a
      new key/value pair is added to a <literal
      moreinfo="none">MultiMap</literal>, the value is added to the collection
      of values for that key. The <literal moreinfo="none">MultiMap</literal>
      also provides a way to remove a specific key/value pair. The following
      example demonstrates the use of <literal
      moreinfo="none">MultiMap</literal>:</para>

      <programlisting format="linespecific" id="I_5_tt228">import org.apache.commons.collections.MultiMap;
import org.apache.commons.collections.MultiHashMap;

MultiMap map = new MultiHashMap( );

map.put( "ONE", "TEST" );
map.put( "TWO", "PICNIC" );

map.put( "ONE", "HELLO" );
map.put( "TWO", "TESTIMONY" );

Set keySet = map.keySet( );
Iterator keyIterator = keySet.iterator( );
while( keyIterator.hasNext( ) ) {
    Object key = keyIterator.next( );

    System.out.print( "Key: " + key + ", " );

    Collection values = (Collection) map.get( key );
    Iterator valuesIterator = values.iterator( );
    while( valuesIterator.hasNext( ) ) {
        System.out.print( "Value: " + valuesIterator.next( ) + ". " );
    }

    System.out.print( "\n" );
}</programlisting>

      <para>Each key in a <literal moreinfo="none">MultiMap</literal>
      corresponds to a collection of values. This example produces the
      following output while iterating through all values for each key:</para>

      <programlisting format="linespecific" id="I_5_tt229">Key: ONE, Value: TEST. Value: HELLO
Key: TWO, Value: PICNIC. Value: Testimony</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>In a traditional <literal moreinfo="none">Map</literal>, a key is
      removed with <literal moreinfo="none">map.remove( )</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2541" significance="normal">
          <primary>map.remove( ) method</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2542"
          significance="normal">
          <primary>methods</primary>

          <secondary>map.remove( )</secondary>
        </indexterm>; this method removes the specified key from the map. In a
      <literal moreinfo="none">MultiMap</literal>, a specific key/value pair
      can be removed from a key's value collection. When removing a specific
      pair, the value is extracted from a key's value collection. <link
      linkend="jakartackbk-CHP-5-EX-10">Example 5-10</link> demonstrates the
      use of a <literal moreinfo="none">MultiMap.remove()</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2543" significance="normal">
          <primary>MultiMap.remove( ) method</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2544"
          significance="normal">
          <primary>methods</primary>

          <secondary>MultiMap.remove( )</secondary>
        </indexterm> method.</para>

      <example id="jakartackbk-CHP-5-EX-10" label="5-10">
        <title>Using MultiMap.remove( )</title>

        <programlisting format="linespecific">package com.discursive.jccook.collections.map;

import org.apache.commons.collections.*;
import java.util.*;

public class MultiMapExample {
    public static void main(String[] args) {
        MultiMapExample example = new MultiMapExample( );
        example.start( );
    }

    public void start( ) {
        MultiMap map = new MultiHashMap( );

        map.put( "ONE", "TEST" );
        map.put( "ONE", "WAR" );
        map.put( "ONE", "CAR" );
        map.put( "ONE", "WEST" );

        map.put( "TWO", "SKY" );
        map.put( "TWO", "WEST" );
        map.put( "TWO", "SCHOOL" );

        // At this point "ONE" should correspond to "TEST", "WAR", "CAR", "WEST"
        map.remove( "ONE", "WAR" );
        map.remove( "ONE", "CAR" );

        // The size of this collection should be two "TEST", "WEST"
        Collection oneCollection = (Collection) map.get("ONE");

        // This collection should be "TEST", "WEST", "SKY", "WEST", "SCHOOL"
        Collection values = map.values( );
    }
}</programlisting>
      </example>

      <para>The <literal moreinfo="none">MultiMap</literal> is relevant when
      one object is associated with many different objects. A sensible example
      would be a <literal moreinfo="none">MultiMap</literal> of people to the
      languages they speak fluently, and the following example demonstrates
      such a <literal moreinfo="none">Map</literal>:</para>

      <programlisting format="linespecific" id="I_5_tt230">MultiMap languageAbility = new MultiHashMap( );

languageAbility.put( "Tom", "French" );
languageAbility.put( "Chris", "Spanish" );
languageAbility.put( "Chris", "German" );
languageAbility.put( "John", "Arabic" );
languageAbility.put( "Tom", "Pashto" );

// What languages does Tom speak?
Collection languages = (Collection) languageAbility.get("Tom");
Iterator languageIterator = languages.iterator( );
while( languageIterator.hasNext( ) ) {
    System.out.println( "Tom speaks " + languageIterator.next( ) );
}</programlisting>

      <para>If you had to locate people who were fluent in a given language,
      it would be equally as valid to use languages as keys and names as
      values. One could then query the <literal
      moreinfo="none">MultiMap</literal> for a list of people who speak a
      certain language. If your system contains two collections of objects
      that have a<indexterm class="endofrange"
      id="jakartackbk-CHP-5-ITERM-2545" significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2534"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2546"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2535"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2547"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2536"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2548"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2537"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2549"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2538"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2550"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2539"></indexterm> many-to-many
      relationship, these<indexterm id="jakartackbk-CHP-5-ITERM-2551"
          significance="normal">
          <primary>relationships</primary>

          <secondary>MultiMap</secondary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2552"
          significance="normal">
          <primary>MultiMap</primary>
        </indexterm> relationships can be managed with two instances of
      <literal moreinfo="none">MultiMap</literal>.</para>
    </sect2>
  </sect1>

  <sect1 id="collections-sect-key-by-value" label="5.11" role="Recipe">
    <title>Retrieving a Key by a Value</title>

    <sect2>
      <title>Problem</title>

      <para>You need a <literal moreinfo="none">Map</literal> that allows you
      to access<indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2553" significance="normal">
          <primary>Commons Collections</primary>

          <secondary>key by value retrieval</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2554" significance="normal">
          <primary>collections</primary>

          <secondary>key by value retrieval</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2555" significance="normal">
          <primary>keys</primary>

          <secondary>value retrieval</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2556" significance="normal">
          <primary>objects</primary>

          <secondary>Collections</secondary>

          <tertiary>key by value retrieval</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2557" significance="normal">
          <primary>values</primary>

          <secondary>key by value retrieval</secondary>
        </indexterm> a value by a key and a key by a value.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para><literal moreinfo="none">BidiMap</literal> in Commons Collections
      provides an implementation of <literal moreinfo="none">Map</literal>,
      which can be reversed if both the keys and values are unique; you can
      use a <literal moreinfo="none">BidiMap</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2558" significance="normal">
          <primary>BidiMap</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2559"
          significance="normal">
          <primary>access</primary>

          <secondary>BidiMap</secondary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2560"
          significance="normal">
          <primary>mapping</primary>

          <secondary>BidiMap</secondary>
        </indexterm> to retrieve a value for a key or a key for a value. The
      following example demonstrates the use of a <literal
      moreinfo="none">BidiMap</literal> to access state names by state
      abbreviation and state abbreviations by state names:</para>

      <programlisting format="linespecific" id="I_5_tt231">BidiMap bidiMap = new DualHashBidiMap( );

bidiMap.put( "il", "Illinois" );
bidiMap.put( "az", "Arizona" );
bidiMap.put( "va", "Virginia" );

// Retrieve the key with a value via the inverse map
String vaAbbreviation = bidiMap.inverseBidiMap( ).get( "Virginia" );
 
// Retrieve the value from the key
String illinoisName = bidiMap.get( "il" );</programlisting>

      <para><literal moreinfo="none">DualHashBidiMap</literal> stores keys and
      values in two <literal moreinfo="none">HashMap</literal> instances. One
      <literal moreinfo="none">HashMap</literal> stores keys as keys and
      values as values, and the other <literal
      moreinfo="none">HashMap</literal> stores the inverse—values as keys and
      keys as values.</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>In <link linkend="jakartackbk-CHP-5-EX-11">Example 5-11</link>, a
      <literal moreinfo="none">BidiMap</literal> is used to store country
      names and country codes; an application stores ISO country codes and
      translates between ISO country codes and country names to present
      intelligible output—"us" is translated to "United States."
      Alternatively, when a user types in a name of a country, the application
      needs to be able to produce the country code for that country
      name—"United States" must be translated back to "us."</para>

      <example id="jakartackbk-CHP-5-EX-11" label="5-11">
        <title>Storing ISO country codes in a BidiMap</title>

        <programlisting format="linespecific">package com.discursive.jccook.collections.bidi;

import org.apache.commons.collections.BidiMap;
import org.apache.commons.collections.bidimap.DualHashBidiMap;

public class BidiMapExample {

    private BidiMap countryCodes = new DualHashBidiMap( );

    public static void main(String[] args) {
        BidiMapExample example = new BidiMapExample( );
        example.start( );
    }
    
    private void start( ) {
        populateCountryCodes( );
        
        String countryName = (String) countryCodes.get( "tr" );
        System.out.println( "Country Name for code 'tr': " + countryName );

        String countryCode = 
            (String) countryCodes.inverseBidiMap( ).get("Uruguay");
        System.out.println( "Country Code for name 'Uruguay': " + countryCode );
            
        countryCode = (String) countryCodes.getKey("Ukraine");
        System.out.println( "Country Code for name 'Ukraine': " + countryCode );
    }
    
    private void populateCountryCodes( ) {
        countryCodes.put("to","Tonga");
        countryCodes.put("tr","Turkey");
        countryCodes.put("tv","Tuvalu");
        countryCodes.put("tz","Tanzania");
        countryCodes.put("ua","Ukraine");
        countryCodes.put("ug","Uganda");
        countryCodes.put("uk","United Kingdom");
        countryCodes.put("um","USA Minor Outlying Islands");
        countryCodes.put("us","United States");
        countryCodes.put("uy","Uruguay");
    }
}</programlisting>
      </example>

      <para>The previous example makes sense because country codes and country
      names are both unique; there is only one entry for "Djibouti," "dj,"and
      no other country has an overlapping code because country codes are
      defined by an International Organization for Standardization (ISO)
      standard, ISO 3166. If you attempt to insert a duplicate key in a
      regular map, the existing entry with the same key would be replaced by
      the new value. In a <literal moreinfo="none">BidiMap</literal>, if you
      insert a duplicate value, or a <emphasis>duplicate key</emphasis>, the
      entry holding this value is replaced by a new entry. The following
      example illustrates this concept:</para>

      <programlisting format="linespecific" id="I_5_tt232">private BidiMap bidiMap = new DualHashBidiMap( );

// Insert initial content { "one:"red", "two":"green", "three":"blue" }
bidiMap.put("one","red");
bidiMap.put("two","green");
bidiMap.put("three","blue");

// replace "one" key entry
bidiMap.put("one","black");

// replace "green" value entry
bidiMap.put("five","green");

// Contents are now { "one":"black", "three":"blue", "five":"green" }</programlisting>

      <para>Changing key "one," value "black" replaces the original key "one,"
      value "red" because the key is duplicated; this behavior is consistent
      with a normal implementation of <literal moreinfo="none">Map</literal>.
      The difference in a <literal moreinfo="none">BidiMap</literal> is that
      when adding key "five," value "green" to a <literal
      moreinfo="none">BidiMap</literal>, the previous key "two," value "green"
      is replaced with a new entry because "green" is a duplicate value. A
      regular <literal moreinfo="none">Map</literal> simply adds another
      entry, and getting the value of either the "five," or "two," key would
      return the value "green." Because "green" already occurs as a key in the
      inverse map, the entry corresponding to the "two," key is removed and
      replaced by a new entry. Bidirectional access to keys by value is only
      possible if keys and values form two unique sets.</para>

      <para>There are three implementations of the <literal
      moreinfo="none">BidiMap</literal> interface: <literal
      moreinfo="none">DualHashBidiMap</literal>, <literal
      moreinfo="none">DialTreeBidiMap</literal>, and <literal
      moreinfo="none">TreeBidiMap</literal>. A <literal
      moreinfo="none">DualHashBidiMap</literal> is the simplest option,
      storing keys and values in two separate instances of <literal
      moreinfo="none">HashMap</literal>. When a value is requested by key, one
      <literal moreinfo="none">HashMap</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2561" significance="normal">
          <primary>HashMap</primary>
        </indexterm> is consulted, and when a key is requested by value, the
      inverse <literal moreinfo="none">HashMap</literal> is consulted. The
      <literal moreinfo="none">DualHashMap</literal> is likely to be your
      implementation of choice if it is not important to keep track of the
      insertion order; it has a straightforward implementation using the
      familiar <literal moreinfo="none">HashMap</literal>.</para>

      <para>If you need to preserve the order of <indexterm
          id="jakartackbk-CHP-5-ITERM-2562" significance="normal">
          <primary>country codes</primary>
        </indexterm>insertion, a <literal
      moreinfo="none">DualTreeBidiMap</literal> uses two separate <literal
      moreinfo="none">TreeMap</literal> instances to hold the regular and
      inverse mappings. This implementation implements the <literal
      moreinfo="none">SortedMap</literal> interface that keeps track of the
      order of insertion and provides <literal moreinfo="none">subMap(
      )</literal>, <literal moreinfo="none">headMap( )</literal>, and <literal
      moreinfo="none">tailMap( )</literal> methods. A third implementation,
      <literal moreinfo="none">TreeBidiMap</literal>, implements <literal
      moreinfo="none">BidiMap</literal> without maintaining two internal
      storage maps. Instead, <literal moreinfo="none">TreeBidiMap</literal>
      stores nodes in a red-black tree, identifying each node as both a key
      and a value; it costs twice as much to <literal moreinfo="none">put(
      )</literal> into a <literal moreinfo="none">TreeBidiMap</literal>, but
      this implementation comes in handy if you are worried about memory
      consumption—it does not need to store each key and value twice in two
      maps.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>This example used ISO 3166 country<indexterm class="endofrange"
      id="jakartackbk-CHP-5-ITERM-2563" significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2553"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2564"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2554"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2565"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2555"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2566"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2556"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2567"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2557"></indexterm> codes, a list of
      every country and corresponding two letter country code. If you are
      writing an application for a worldwide audience, you may find the
      following list helpful: <systemitem moreinfo="none"
      role="url">http://www.iso.ch/iso/en/prods-services/iso3166ma/02iso-3166-code-lists/list-en1.html</systemitem>.</para>
    </sect2>
  </sect1>

  <sect1 id="collections-sect-case-insensitive" label="5.12" role="Recipe">
    <title>Using a Case-Insensitive Map</title>

    <sect2>
      <title>Problem</title>

      <para>You need to use a <literal moreinfo="none">Map</literal> with
      <literal moreinfo="none">String</literal> <indexterm
          class="startofrange" id="jakartackbk-CHP-5-ITERM-2568"
          significance="normal">
          <primary>Commons Collections</primary>

          <secondary>case-insensitive maps</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2569" significance="normal">
          <primary>collections</primary>

          <secondary>case-insensitive maps</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2570" significance="normal">
          <primary>case-insensitive maps</primary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2571" significance="normal">
          <primary>objects</primary>

          <secondary>Collections</secondary>

          <tertiary>case-insensitive maps</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2572" significance="normal">
          <primary>mapping</primary>

          <secondary>case-insensitive maps</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2573" significance="normal">
          <primary>capitalization, case-insensitive maps</primary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2574" significance="normal">
          <primary>values</primary>

          <secondary>case-insensitive maps</secondary>
        </indexterm>keys that will <indexterm
          id="jakartackbk-CHP-5-ITERM-2575" significance="normal">
          <primary>keys</primary>

          <secondary>case-insensitive maps</secondary>
        </indexterm>ignore the capitalization of a key when retrieving a
      value.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use a <literal moreinfo="none">CaseInsensitiveMap</literal>
      <indexterm id="jakartackbk-CHP-5-ITERM-2576" significance="normal">
          <primary>CaseInsensitiveMap</primary>
        </indexterm> from the Commons Collections. This implementation of
      <literal moreinfo="none">Map</literal> takes <literal
      moreinfo="none">String</literal> keys and provides case-insensitive
      access. An entry with a key "Test" can be retrieved with the strings
      "TEST," "test," and "tEST." Here is a small example demonstrating the
      case insensitivity:</para>

      <programlisting format="linespecific" id="I_5_tt233">import java.util.*;
import org.apache.commons.collection.map.CaseInsensitiveMap;

Map grades = new CaseInsensitiveMap( );
grades.put( "Fortney", "B-" );
grades.put( "Puckett", "D+" );
grades.put( "Flatt", "A-" );

String grade1 = (String) grades.get( "puckett" );
String grade2 = (String) grades.get( "FLATT" );</programlisting>

      <para>In this example, the grades are stored with a capitalized last
      name, and the results are retrieved with irregularly capitalized last
      names. This example returns the grades for "Puckett" and "Flatt" even
      though they were retrieved with "puckett" and "FLATT."</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para><link linkend="jakartackbk-CHP-5-EX-12">Example 5-12</link>
      demonstrates the use of <literal
      moreinfo="none">CaseInsensitiveMap</literal> to access state names by
      state abbreviations regardless of capitalization. This is useful when an
      application is requesting a state from a user in a form to capture an
      address. If a user enters "il," "IL," or "Il," you need to be able to
      return "Illinois."</para>

      <example id="jakartackbk-CHP-5-EX-12" label="5-12">
        <title>Using a CaseInsensitiveMap for U.S. states</title>

        <programlisting format="linespecific">package com.discursive.jccook.collections.insensitive;

import java.util.Map;
import org.apache.commons.collections.map.CaseInsensitiveMap;

public class CaseInsensitiveExample {

    Map states = new CaseInsensitiveMap( );

    public static void main(String[] args) {
        CaseInsensitiveExample example = new CaseInsensitiveExample( );
        example.start( );
    }
    
    private void start( ) {
        states.put("IL", "Illinois");
        states.put("PA", "Pennsylvania");
        states.put("GA", "Georgia");
        states.put("AZ", "Arizona");
    
        String stateName = (String) states.get( "il" );
        System.out.println( "Value retrieved for 'il': " + stateName );

        stateName = (String) states.get( "IL" );
        System.out.println( "Value retrieved for 'IL': " + stateName );

        stateName = (String) states.get( "iL" );
        System.out.println( "Value retrieved for 'iL': " + stateName );

    }
}</programlisting>
      </example>

      <para><link linkend="jakartackbk-CHP-5-EX-12">Example 5-12</link>
      populates a <literal moreinfo="none">CaseInsensitiveMap</literal> with
      state abbreviations and state names, and it retrieves the state name for
      three different capitalizations of "IL": "iL," "IL," and "il." For all
      three keys, the <literal moreinfo="none">CaseInsensitiveMap</literal>
      returns the proper state name—"Illinois"—as illustrated by the output
      from the previous example:</para>

      <programlisting format="linespecific" id="I_5_tt234">Value retrieved for 'il': Illinois
Value retrieved for 'IL': Illinois
Value retrieved for 'iL': Illinois</programlisting>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>If you are interested in how this class works, take a look at the
      source for <literal moreinfo="none">CaseInsensitiveMap</literal>, and
      you will see that this implementation of <literal
      moreinfo="none">Map</literal> extends the <literal
      moreinfo="none">AbstractHashedMap</literal> class in the <literal
      moreinfo="none">org.apache.commons.collections.map</literal> package. It
      would be just as easy to decorate a <literal
      moreinfo="none">Map</literal> with a <literal
      moreinfo="none">Transformer</literal> object to provide case
      insensitivity. <link linkend="jakartackbk-CHP-5-SECT-16">Recipe
      5.16</link> discusses the use of a <literal
      moreinfo="none">Transformer</literal> to <indexterm class="endofrange"
      id="jakartackbk-CHP-5-ITERM-2577" significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2568"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2578"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2569"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2579"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2570"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2580"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2571"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2581"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2572"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2582"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2573"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2583"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2574"></indexterm>alter objects as
      they are stored in a <literal
      moreinfo="none">Collection</literal>.</para>
    </sect2>
  </sect1>

  <sect1 id="collections-sect-typed" label="5.13" role="Recipe">
    <title>Creating Typed Collections and Maps</title>

    <sect2>
      <title>Problem</title>

      <para>You need to guarantee that <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2584" significance="normal">
          <primary>Commons Collections</primary>

          <secondary>typed collections</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2585" significance="normal">
          <primary>collections</primary>

          <secondary>typed</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2586" significance="normal">
          <primary>typed collections</primary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2587" significance="normal">
          <primary>objects</primary>

          <secondary>Collections</secondary>

          <tertiary>typed collections</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2588" significance="normal">
          <primary>mapping</primary>

          <secondary>typed collections</secondary>
        </indexterm>a <literal moreinfo="none">Collection</literal> or a
      <literal moreinfo="none">Map</literal> only contains objects of a
      certain type.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">TypedCollection.decorate()</literal>
      <indexterm id="jakartackbk-CHP-5-ITERM-2589" significance="normal">
          <primary>TypedCollection.decorate( ) method</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2590"
          significance="normal">
          <primary>methods</primary>

          <secondary>TypedCollection.decorate( )</secondary>
        </indexterm> to create a <literal moreinfo="none">Collection</literal>
      that only accepts objects of a specified type. Supply an existing
      <literal moreinfo="none">Collection</literal> along with the <literal
      moreinfo="none">Class</literal> that all elements should be constrained
      to. <literal moreinfo="none">TypedCollection</literal> will decorate
      this existing <literal moreinfo="none">Collection</literal>, validating
      elements as they are added to a <literal
      moreinfo="none">Collection</literal>. The following example creates a
      <literal moreinfo="none">Collection</literal> that will only accept
      strings:</para>

      <programlisting format="linespecific" id="I_5_tt235">List existingList = new ArrayList( );
Collection typedCollection = TypedCollection.decorate( existingList, 
String.class );

// This will add a String
typedCollection.add( "STRING" );

// And, This will throw an IllegalArgumentException
typedCollection.add( new Long(28) );</programlisting>

      <para>Similarly, if you want to constrain keys and values to specified
      types, pass a <literal moreinfo="none">Map</literal> to <literal
      moreinfo="none">TypedMap.decorate( )</literal> method, specifying a
      <literal moreinfo="none">Class</literal> for both the key and the value.
      In the following example, <literal moreinfo="none">typedMap</literal>
      only accepts <literal moreinfo="none">String</literal> keys and <literal
      moreinfo="none">Number</literal> values:</para>

      <programlisting format="linespecific" id="I_5_tt236">Map existingMap = new HashMap( );
Map typedMap = TypedMap.decorate( existingMap, String.class, Number.class );

// This will add a String key and a Double value
typedMap.put( "TEST", new Double( 3.40 ) );

// Both of these throw an IllegalArgumentException
typedMap.put( new Long(202), new Double( 3.40 ) );
typedMap.put( "BLAH", "BLAH" );</programlisting>

      <para><literal moreinfo="none">TypedCollection</literal> and <literal
      moreinfo="none">TypedMap</literal> will decorate any existing <literal
      moreinfo="none">Collection</literal> or <literal
      moreinfo="none">Map</literal> and will throw an <literal
      moreinfo="none">IllegalArgumentException</literal> if you try to add an
      incompatible type.</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>A <literal moreinfo="none">Map</literal> frequently contains keys
      and values with consistent types; for instance, an application that
      keeps track of <literal moreinfo="none">Person</literal> objects by name
      most likely has a <literal moreinfo="none">personMap</literal> with
      <literal moreinfo="none">Person</literal> values and <literal
      moreinfo="none">String</literal> keys. Rarely does a <literal
      moreinfo="none">Map</literal> hold a wide diversity of types. <literal
      moreinfo="none">Collection</literal>s and <literal
      moreinfo="none">Map</literal>s are not type-safe, and this lack of type
      safety means that unexpected objects may be cast to incompatible types,
      causing nasty <literal moreinfo="none">ClassCastException</literal>s. It
      is unlikely that every time you call <literal moreinfo="none">get(
      )</literal> and cast the resulting object, you catch <literal
      moreinfo="none">ClassCastException</literal>; and, in most systems, it
      is reasonable to assume that no one has put an incompatible type into a
      <literal moreinfo="none">Map</literal>. But, if a <literal
      moreinfo="none">Map</literal> plays a central role in a critical
      application, you may want an extra layer of validation; decorate your
      maps with <literal moreinfo="none">TypedMap</literal> to ensure that a
      <literal moreinfo="none">Map</literal> contains consistent types. There
      is little penalty for decorating a <literal
      moreinfo="none">Map</literal> as such, and if someone writes code to
      insert invalid input, your application should fail immediately with an
      <literal moreinfo="none">IllegalArgumentException</literal>.</para>

      <para>If your application uses a <literal
      moreinfo="none">TypedMap</literal>, it is easier to track down defects.
      If a <literal moreinfo="none">ClassCastException</literal> is thrown
      when calling <literal moreinfo="none">get( )</literal>, you then need to
      work backward to find out where the offending object was put into a
      <literal moreinfo="none">Map</literal>. An alternative is to validate
      each object as it is added to a <literal moreinfo="none">Map</literal>.
      If the <literal moreinfo="none">put( )</literal> method throws <literal
      moreinfo="none">IllegalArgumentException</literal>, it will be easier to
      identify the offending code.</para>

      <para>Java 5.0 adds the idea of generics—compile-time type safety for
      any number of objects including <literal
      moreinfo="none">Collection</literal>s and <literal
      moreinfo="none">Map</literal>s. But, if you are stuck with an older
      version of the JDK, you can use Commons Collections to create a <literal
      moreinfo="none">Collection</literal> that only accepts input of a
      certain type. <literal moreinfo="none">TypedSet</literal>, <literal
      moreinfo="none">TypedBag</literal>, <literal
      moreinfo="none">TypedList</literal>, <literal
      moreinfo="none">TypedMap</literal>, <literal
      moreinfo="none">TypedBuffer</literal>, <literal
      moreinfo="none">TypedSortedSet</literal>, <literal
      moreinfo="none">TypedSortedBag</literal>, <literal
      moreinfo="none">TypedSortedMap</literal> all provide the same decoration
      as <literal moreinfo="none">TypedCollection</literal>, but they return a
      specific interface; for example, <literal
      moreinfo="none">TypedList</literal> decorates and returns a <literal
      moreinfo="none">List</literal>, and <literal
      moreinfo="none">TypedSet</literal> decorates and returns a <literal
      moreinfo="none">Set</literal>. <link
      linkend="jakartackbk-CHP-5-EX-13">Example 5-13</link> demonstrates the
      use of the <literal moreinfo="none">TypedList</literal> decorator to
      return a <literal moreinfo="none">List</literal> instead of a <literal
      moreinfo="none">Collection</literal>.</para>

      <example id="jakartackbk-CHP-5-EX-13" label="5-13">
        <title>Using TypedList to decorate a list</title>

        <programlisting format="linespecific">package com.discursive.jccook.collections.typed;

import java.util.ArrayList;
import java.util.List;

import org.apache.commons.collections.list.TypedList;

public class TypedListExample {
    
    private List hostNames;

    public static void main(String[] args) {
        TypedListExample example = new TypedListExample( );
        example.start( );
    }
    
    public void start( ) {
        // Make sure that items added to this
        hostNames = TypedList.decorate(  new ArrayList( ), String.class );

        // Add two String objects
        hostNames.add( "papp01.thestreet.com" );
        hostNames.add( "test.slashdot.org" );
        
        // Try to add an Integer
        try {        
            hostNames.add( new Integer(43) );
        } catch( IllegalArgumentException iae ) {
            System.out.println( "Adding an Integer Failed as expected" );
        }
        
        // Now we can safely cast without the possibility of a 
        // ClassCastException
        String hostName = (String) hostNames.get(0);
        
    }
}</programlisting>
      </example>

      <para>If a <literal moreinfo="none">List</literal> decorated with
      <literal moreinfo="none">TypedList</literal> encounters an invalid
      object, the <literal moreinfo="none">add( )</literal> method will throw
      an <literal moreinfo="none">IllegalArgumentException</literal>.</para>

      <tip id="jakartackbk-CHP-5-NOTE-58" role="ora">
        <para>A <literal moreinfo="none">Typed&lt;X&gt;</literal> decorated
        <literal moreinfo="none">Collection</literal> will not be able to
        provide the compile-time type safety of Java 5.0's generics, but it
        will enforce a restriction on what it can accept—it is up to you to
        catch the runtime exception.</para>
      </tip>

      <para><literal moreinfo="none">TypedMap</literal> allows you to
      constrain both the keys and values of a map. <literal
      moreinfo="none">TypedMap.decorate( )</literal> takes three parameters:
      the <literal moreinfo="none">Map</literal> to decorate, the key <literal
      moreinfo="none">Class</literal>, and the value <literal
      moreinfo="none">Class</literal>. To create a <literal
      moreinfo="none">Map</literal> that only constrains key types, pass in a
      <literal moreinfo="none">null</literal> value for the value type. To
      create a <literal moreinfo="none">Map</literal> that only validates the
      type of the value, pass in a <literal moreinfo="none">null</literal> for
      the key type. <link linkend="jakartackbk-CHP-5-EX-14">Example
      5-14</link> uses <literal moreinfo="none">TypedMap.decorate( )</literal>
      to create a <literal moreinfo="none">Map</literal> that only accepts
      <literal moreinfo="none">String</literal> keys and <literal
      moreinfo="none">Number</literal> values.</para>

      <example id="jakartackbk-CHP-5-EX-14" label="5-14">
        <title>Decorating a map with TypedMap</title>

        <programlisting format="linespecific">package com.discursive.jccook.collections.typed;

import java.util.HashMap;
import java.util.Map;

import org.apache.commons.collections.map.TypedMap;

public class TypedMapExample {
    
    private Map variables;

    public static void main(String[] args) {
        TypedMapExample example = new TypedMapExample( );
        example.start( );
    }
    
    public void start( ) {
        // Make sure that items added to this
        variables = 
            TypedMap.decorate(  new HashMap( ), String.class, Number.class );

        // Add two String objects
        variables.put( "maxThreads", new Integer(200) );
        variables.put( "minThreads", new Integer(20) );
        variables.put( "lightSpeed", new Double( 2.99792458e8 ) );
        
        // Try to add a String value
        try {        
            variables.put( "server", "test.oreilly.com" );
        } catch( IllegalArgumentException iae ) {
            System.out.println( "Adding an String value Failed as expected" );
        }

        // Try to add an Integer key
        try {        
            variables.put( new Integer(30), "test.oreilly.com" );
        } catch( IllegalArgumentException iae ) {
            System.out.println( "Adding an Integer key Failed as expected" );
        }
        
        // Now we can safely cast without the possibility of a ClassCastException
        Number reading = (Number) variables.get("lightSpeed");
        
    }
}</programlisting>
      </example>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>Java 5.0 has added generics—a welcome addition. For more
      information about generics, look at the release notes for Java 5.0 at
      <systemitem moreinfo="none"
      role="url">http://java.sun.com/j2se/1.5.0/docs/relnotes/features.html#generics</systemitem>.</para>

      <para>For more information about the decorator design pattern, read the
      classic <emphasis>Design Patterns: Elements of Reusable Object-Oriented
      Software</emphasis>, by Erich Gamma et al., or take a look at this
      onJava.com article by Budi Kurniawan: <systemitem moreinfo="none"
      role="url">http://www.onjava.com/pub/a/onjava/2003/02/05/decorator.html</systemitem>,
      which deals with the decorator pattern as applied to Java Swing
      development, but this pattern also has relevance outside of a GUI
      development context.</para>

      <para>This <literal moreinfo="none">TypedCollection</literal> decorator
      is a specialized version of a <literal
      moreinfo="none">PredicatedCollection</literal>. Type-safety is
      implemented through the <indexterm class="endofrange"
      id="jakartackbk-CHP-5-ITERM-2591" significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2584"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2592"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2585"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2593"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2586"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2594"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2587"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2595"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2588"></indexterm>use of an <literal
      moreinfo="none">InstanceofPredicate</literal>, and the next recipe
      discusses the use of a <literal
      moreinfo="none">PredicatedMap</literal>.</para>
    </sect2>
  </sect1>

  <sect1 id="collections-sect-constrain-map" label="5.14" role="Recipe">
    <title>Constraining Map Values</title>

    <sect2>
      <title>Problem</title>

      <para>You need to ensure that all<indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2596" significance="normal">
          <primary>Commons Collections</primary>

          <secondary>map value constraints</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2597" significance="normal">
          <primary>collections</primary>

          <secondary>map value constraints</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2598" significance="normal">
          <primary>constraints</primary>

          <secondary>map values</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2599" significance="normal">
          <primary>objects</primary>

          <secondary>Collections</secondary>

          <tertiary>map value constraints</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2600" significance="normal">
          <primary>mapping</primary>

          <secondary>value constraints</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2601" significance="normal">
          <primary>values</primary>

          <secondary>map constraints</secondary>
        </indexterm> values added to a <literal moreinfo="none">Map</literal>
      satisfy a set of arbitrary conditions.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Decorate an existing <literal moreinfo="none">Map</literal> with
      <literal moreinfo="none">PredicatedMap</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2602" significance="normal">
          <primary>PredicatedMap</primary>
        </indexterm> from Commons Collections. <literal
      moreinfo="none">Predicate</literal>s add an inbound validation to a
      <literal moreinfo="none">Map</literal>, validating keys or values any
      time an entry is added to a <literal
      moreinfo="none">PredicatedMap</literal>. If a <literal
      moreinfo="none">Predicate</literal> assigned to a key or value returns
      <literal moreinfo="none">false</literal>, <literal
      moreinfo="none">put()</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2603" significance="normal">
          <primary>put( ) method</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2604"
          significance="normal">
          <primary>methods</primary>

          <secondary>put</secondary>
        </indexterm> throws an <literal
      moreinfo="none">IllegalArgumentException</literal>. The following
      example decorates a <literal moreinfo="none">HashMap</literal> with
      <literal moreinfo="none">PredicatedMap</literal>—two <literal
      moreinfo="none">Predicate</literal>s are created to validate the keys
      and the values:</para>

      <programlisting format="linespecific" id="I_5_tt237">import java.util.*;
import org.apache.commons.collections.map.PredicatedMap;
import org.apache.commons.collections.Predicate;
import org.apache.commons.collections.functors.EqualPredicate;
import org.apache.commons.collections.functors.InstanceofPredicate;
import org.apache.commons.collections.functors.OrPredicate;

<userinput moreinfo="none">// Create a Predicate that only accepts Strings</userinput>
               <userinput moreinfo="none">Predicate onlyStrings = new InstanceofPredicate( String.class );</userinput>

               <emphasis role="bold">// Create a Predicate that only allows "green" or "red</emphasis>"
Predicate onlyGreen = new EqualPredicate( "green" );
Predicate onlyRed = new EqualPredicate( "red" );
<emphasis role="bold">Predicate greenOrRed = new OrPredicate( onlyGreen, onlyRed );</emphasis>

               <userinput moreinfo="none">// Created a Decorated Map - accepting String keys and "green" or "red" values</userinput>
               <userinput moreinfo="none">Map map = PredicatedMap.decorate( new HashMap( ), onlyStrings, greenOrRed );</userinput>

// All of these puts should work
map.put( "tony" , "green" );
map.put( "alice" , "red" );
map.put( "mike" , "red" );
map.put( "bobby" , "green" );

// All of these puts should throw an IllegalArgumentException
map.put( new Double(4.0) , "green" );
map.put( "alice" , "purple" );
map.put( new Long(32) , new Long(43) );</programlisting>

      <para>In the previous example, keys are validated by a simple <literal
      moreinfo="none">InstanceofPredicate</literal>, which ensures that each
      key is a <literal moreinfo="none">String</literal>. The values are
      validated with an <literal moreinfo="none">OrPredicate</literal>, which
      combines two <literal moreinfo="none">EqualPredicates</literal>; values
      are accepted if they are equal to the strings "green" or "red."</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>A <literal moreinfo="none">PredicatedMap</literal> can work with
      any <literal moreinfo="none">Predicate</literal> no matter how simple or
      complex. Passing in a <literal moreinfo="none">null</literal> value for
      either the key or value <literal moreinfo="none">Predicate</literal>
      instructs the <literal moreinfo="none">PredicatedMap</literal> not to
      validate keys or values. In the following example, a <literal
      moreinfo="none">PredicatedMap</literal> decorates a <literal
      moreinfo="none">HashMap</literal> to ensure that a <literal
      moreinfo="none">Map</literal> contains valid <literal
      moreinfo="none">Team</literal> values:</para>

      <programlisting format="linespecific" id="I_5_tt238">import org.apache.commons.collections.functors.AndPredicate;
import org.apache.commons.collections.map.PredicatedMap;

<emphasis role="bold">// Create the Predicates</emphasis>
ValidTeamPredicate validTeam = new ValidTeamPredicate( );
ValidCoachPredicate validCoach = new ValidCoachPredicate( );

<emphasis role="bold">// Tie two Predicates together into an AndPredicate</emphasis>
AndPredicate valuePredicate = new AndPredicate( validTeam, validCoach );
        
<emphasis role="bold">// Decorate a HashMap with a predicate on the value</emphasis>
Map teamMap = PredicatedMap.decorate( new HashMap( ), null, valuePredicate);
        
<emphasis role="bold">// Manufacture some teams</emphasis>
Team redSox = new Team( "Red Sox", new Coach( "Patrick", "Moloney") );
Team yankees= new Team( "Yankees", new Coach( "David", "McGarry") );
Team dodgers = new Team( "Dodgers", new Coach( "Nick", "Taylor") );
Team twins = new Team( null, new Coach( "Patrick", "Moloney") );
Team braves = new Team( "Braves", null );
        
<emphasis role="bold">// The following put calls should work fine</emphasis>
teamMap.put( "RedSox", redSox );
teamMap.put( "Yankees", yankees );
teamMap.put( "Dodgers", dodgers );
        
<emphasis role="bold">// This put should fail because the team name is null</emphasis>
try {
    teamMap.put( "Twins", twins);
} catch( IllegalArgumentException iae ) {
    System.out.println( "Twins put failed, as expected" );
}

<emphasis role="bold">// This put should fail because the coach is null</emphasis>
try {
    teamMap.put( "Braves", braves);
} catch( IllegalArgumentException iae ) {
    System.out.println( "Braves put failed, as expected" );
}</programlisting>

      <para>An application can assume that every team in <literal
      moreinfo="none">teamMap</literal> has met the following
      requirements:</para>

      <itemizedlist>
        <listitem>
          <para>Every <literal moreinfo="none">Team</literal> object must have
          a non-<literal moreinfo="none">null</literal> <literal
          moreinfo="none">name</literal> property.</para>
        </listitem>

        <listitem>
          <para>Every <literal moreinfo="none">Team</literal> object must have
          a non-<literal moreinfo="none">null</literal> <literal
          moreinfo="none">coach</literal> property, and this <literal
          moreinfo="none">Coach</literal> object must have a first and last
          name.</para>
        </listitem>
      </itemizedlist>

      <para>The previous example uses two <literal
      moreinfo="none">Predicate</literal> objects to validate both the team
      and the coach. These two custom predicates (<literal
      moreinfo="none">ValidTeamPredicate</literal> and <literal
      moreinfo="none">ValidCoachPredicate)</literal> are defined in Examples
      <link linkend="jakartackbk-CHP-5-EX-15">Example 5-15</link> and <link
      linkend="jakartackbk-CHP-5-EX-16">Example 5-16</link>. These <literal
      moreinfo="none">Predicate</literal> objects are passed to the <literal
      moreinfo="none">PredicatedMap.decorate( )</literal> method to decorate a
      <literal moreinfo="none">Map</literal> with these conditions. The first
      <literal moreinfo="none">Predicate</literal>, <literal
      moreinfo="none">ValidTeamPredicate</literal>, validates a <literal
      moreinfo="none">Team</literal> object to see if it has a non-<literal
      moreinfo="none">null</literal> <literal moreinfo="none">name</literal>
      property.</para>

      <example id="jakartackbk-CHP-5-EX-15" label="5-15">
        <title>A Predicate to validate a Team's name property</title>

        <indexterm id="jakartackbk-CHP-5-ITERM-2605" significance="normal">
          <primary>predicates</primary>

          <secondary>validation</secondary>
        </indexterm>

        <indexterm id="jakartackbk-CHP-5-ITERM-2606" significance="normal">
          <primary>validation</primary>

          <secondary>predicates</secondary>
        </indexterm>

        <programlisting format="linespecific">import org.apache.commons.collections.Predicate;

public class ValidTeamPredicate implements Predicate {

    public boolean evaluate(Object object) {
        Team team = (Team) object;
        return team.getName( ) != null;        
    }

}</programlisting>
      </example>

      <example id="jakartackbk-CHP-5-EX-16" label="5-16">
        <title>Predicate to validate a Team's coach property</title>

        <programlisting format="linespecific">import org.apache.commons.collections.Predicate;

public class ValidCoachPredicate implements Predicate {

    public boolean evaluate(Object object) {
        boolean validCoach = false;
        Team team = (Team) object;
        if( team.getCoach( ) != null &amp;&amp; 
            team.getCoach( ).getFirstName( ) != null &amp;&amp;
            team.getCoach( ).getLastName( ) != null ) {
            validCoach = true;
        }
        return validCoach;
    }

}</programlisting>
      </example>

      <para>The second <literal moreinfo="none">Predicate</literal>, <literal
      moreinfo="none">ValidCoachPredicate</literal>, validates a <literal
      moreinfo="none">Team</literal> object, checking to see if the <literal
      moreinfo="none">coach</literal> property is non-<literal
      moreinfo="none">null</literal>, and that the coach has a first and last
      name.</para>

      <para>In <link linkend="jakartackbk-CHP-5-EX-16">Example 5-16</link>, a
      <literal moreinfo="none">Predicate</literal> is created by combining the
      <literal moreinfo="none">ValidTeamPredicate</literal> and <literal
      moreinfo="none">ValidCoachPredicate</literal> in an <literal
      moreinfo="none">AndPredicate</literal>. A <literal
      moreinfo="none">HashMap</literal> is then decorated with <literal
      moreinfo="none">PredicatedMap.decorate( )</literal>, passing the
      <literal moreinfo="none">AndPredicate</literal> in as the predicate to
      validate <literal moreinfo="none">Map</literal> values. A few <literal
      moreinfo="none">Team</literal> objects are created, all of which are
      valid with the exception of the Twins and the Braves, and, as expected,
      <indexterm class="endofrange" id="jakartackbk-CHP-5-ITERM-2607"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2596"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2608"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2597"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2609"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2598"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2610"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2599"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2611"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2600"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2612"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2601"></indexterm>the Twins and Braves
      cause <literal moreinfo="none">put( )</literal> to throw an <literal
      moreinfo="none">IllegalArgumentException</literal>.</para>
    </sect2>
  </sect1>

  <sect1 id="collections-sect-constrain-list" label="5.15" role="Recipe">
    <title>Constraining List Contents</title>

    <sect2>
      <title>Problem</title>

      <para>You need to constrain objects<indexterm
          id="jakartackbk-CHP-5-ITERM-2613" significance="normal">
          <primary>Commons Collections</primary>

          <secondary>list constraints</secondary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2614"
          significance="normal">
          <primary>collections</primary>

          <secondary>list constraints</secondary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2615"
          significance="normal">
          <primary>constraints</primary>

          <secondary>lists</secondary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2616"
          significance="normal">
          <primary>objects</primary>

          <secondary>Collections</secondary>

          <tertiary>list constraints</tertiary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2617"
          significance="normal">
          <primary>lists</primary>

          <secondary>constraints</secondary>
        </indexterm> that can be added to a <literal
      moreinfo="none">List</literal>.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Decorate a <literal moreinfo="none">List</literal> using <literal
      moreinfo="none">PredicatedList</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2618" significance="normal">
          <primary>PredicatedList</primary>
        </indexterm>. The following example demonstrates the use of <literal
      moreinfo="none">PredicatedList</literal> to create a <literal
      moreinfo="none">List</literal> that only accepts even <literal
      moreinfo="none">Integer</literal> objects:</para>

      <programlisting format="linespecific" id="I_5_tt239">import java.util.*;
import org.apache.commons.collections.list.PredicatedList;
import org.apache.commons.collections.Predicate;
import org.apache.commons.lang.ArrayUtils;

// Create a Predicate that only accepts even Integer objects
Predicate onlyEven = new Predicate( ) {
    public boolean evaluate(Object object) {
        Integer integer = (Integer) object;
        return( integer.intValue( ) % 2 == 0 );
    }
}

List list = PredicatedList.decorate( new ArrayList( ), onlyEven );

list.add( new Integer(1) ); // Will throw IllegalArgumentException
list.add( new Integer(2) );
list.add( new Integer(3) ); // Will throw IllegalArgumentException
list.add( new Integer(4) );</programlisting>

      <para>In this example, attempting to add an <literal
      moreinfo="none">Integer</literal> with an odd value causes an <literal
      moreinfo="none">IllegalArgumentException</literal>, but adding an even
      number does not cause an exception to be thrown.</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>A <literal moreinfo="none">PredicatedList</literal> is very
      similar to a <literal moreinfo="none">PredicatedMap</literal>; this
      decorator works with an existing <literal moreinfo="none">List</literal>
      and adds inbound validation to a <literal
      moreinfo="none">List</literal>. There is no limit to the complexity of
      the <literal moreinfo="none">Predicate</literal> that can be used to
      provide inbound validation to a <literal
      moreinfo="none">List</literal>.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para><literal moreinfo="none">PredicatedList</literal> and <literal
      moreinfo="none">PredicatedMap</literal> are not the only <literal
      moreinfo="none">Collection</literal> decorators available in the Jakarta
      Commons Collections. Any <literal moreinfo="none">Collection</literal>
      interface in the following list can be decorated with a <literal
      moreinfo="none">Predicate</literal>.</para>

      <itemizedlist>
        <listitem>
          <para><literal moreinfo="none">PredicatedBag</literal> decorates a
          <literal moreinfo="none">Bag</literal>.</para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">PredicatedBuffer</literal> decorates
          a <literal moreinfo="none">Buffer</literal>.</para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">PredicatedCollection</literal>
          decorates a <literal moreinfo="none">Collection</literal>.</para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">PredicatedList</literal> decorates a
          <literal moreinfo="none">List</literal>.</para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">PredicatedMap</literal> decorates a
          <literal moreinfo="none">Map</literal>.</para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">PredicatedSet</literal> decorates a
          <literal moreinfo="none">Set</literal>.</para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">PredicatedSortedBag</literal>
          decorates a <literal moreinfo="none">SortedBag</literal>.</para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">PredicatedSortedMap</literal>
          decorates a <literal moreinfo="none">SortedMap</literal>.</para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">PredicatedSortedSet</literal>
          decorates a <literal moreinfo="none">SortedSet</literal></para>
        </listitem>
      </itemizedlist>

      <para>For more information about these utilities, see the Jakarta
      Commons Collections project page at <systemitem moreinfo="none"
      role="url">http://jakarta.apache.org/commons/collections</systemitem>.</para>
    </sect2>
  </sect1>

  <sect1 id="collections-sect-transforming" label="5.16" role="Recipe">
    <title>Transforming Collections</title>

    <sect2>
      <title>Problem</title>

      <para>You need to perform a<indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2619" significance="normal">
          <primary>Commons Collections</primary>

          <secondary>transformation</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2620" significance="normal">
          <primary>collections</primary>

          <secondary>transformation</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2621" significance="normal">
          <primary>objects</primary>

          <secondary>Collections</secondary>

          <tertiary>transformation</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2622" significance="normal">
          <primary>transformation</primary>

          <secondary>collections</secondary>
        </indexterm> transformation using each element in a <literal
      moreinfo="none">Collection</literal>.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">CollectionUtils.transform()</literal>
      <indexterm id="jakartackbk-CHP-5-ITERM-2623" significance="normal">
          <primary>CollectionUtils.transform( ) method</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2624"
          significance="normal">
          <primary>methods</primary>

          <secondary>CollectionUtils.tranform( )</secondary>
        </indexterm>. Supply a <literal moreinfo="none">Collection</literal>
      and a <literal moreinfo="none">Transformer</literal> to this method, and
      this utility will pass each element in the <literal
      moreinfo="none">Collection</literal> to that <literal
      moreinfo="none">Transformer</literal>, returning a new <literal
      moreinfo="none">Collection</literal> containing the results of each
      transformation. The following example demonstrates the use of <literal
      moreinfo="none">transform( )</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2625" significance="normal">
          <primary>transform( ) method</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2626"
          significance="normal">
          <primary>methods</primary>

          <secondary>transform( )</secondary>
        </indexterm> with a custom <literal
      moreinfo="none">Transformer</literal> object:</para>

      <programlisting format="linespecific" id="I_5_tt240">import java.util.*;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.ArrayUtils;
import org.apache.commons.lang.StringUtils;

<userinput moreinfo="none">// Create a transformer that reverses strings.</userinput>
               <userinput moreinfo="none">Transformer reversingTransformer = new Transformer( ) {</userinput>
               <userinput moreinfo="none">    public Object transform(Object object) {</userinput>
               <userinput moreinfo="none">        String string = (String) object;</userinput>
               <userinput moreinfo="none">        return StringUtils.reverse( string );</userinput>
               <userinput moreinfo="none">    }</userinput>
               <userinput moreinfo="none">}</userinput>

String[] array = new String[] { "Aznar", "Blair", "Chirac", "Putin", "Bush" };
List stringList = Arrays.asList( ArrayUtils.clone( array ) );

<userinput moreinfo="none">// Transform each element with a Transformer</userinput>
               <userinput moreinfo="none">CollectionUtils.transform( stringList, reversingTransformer );</userinput>

System.out.println( "Original: " + ArrayUtils.toString( array ) );
System.out.println( "Transformed: " + 
                    ArrayUtils.toString( stringList.toArray( ) ) );</programlisting>

      <para>This example creates a <literal moreinfo="none">List</literal> of
      strings, transforming each element with a <literal
      moreinfo="none">Transformer</literal> that produces reversed strings.
      The <literal moreinfo="none">List</literal> is transformed in-place,
      which means that the contents of the <literal
      moreinfo="none">List</literal> are replaced with the output from the
      <literal moreinfo="none">transform( )</literal> method of the <literal
      moreinfo="none">Transformer</literal>. As expected, the transformed
      <literal moreinfo="none">List</literal> contains reversed
      strings:</para>

      <programlisting format="linespecific" id="I_5_tt241">Original: Aznar, Blair, Chirac, Putin, Bush
Transformed: ranzA, rialB, carihC, nituP, hsuB</programlisting>

      <para><literal moreinfo="none">CollectionUtils.transform( )</literal>
      does not only apply to <literal moreinfo="none">Lists</literal>; any
      object implementing the <literal moreinfo="none">Collection</literal>
      interface can be used with this utility.</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para><literal moreinfo="none">Transformer</literal>s are another form
      of functor that transforms one object into another, leaving the original
      object unchanged. <literal moreinfo="none">Transformer</literal> is a
      very straightforward interface, simply requiring the presence of a
      <literal moreinfo="none">transform( )</literal> method. The <literal
      moreinfo="none">Transformer</literal> interface, like <literal
      moreinfo="none">Predicate</literal>, is augmented by a number of useful
      built-in implementations, which can combine the effects of multiple
      transformers. One of these <literal
      moreinfo="none">Transformer</literal> implementations is the <literal
      moreinfo="none">ChainedTransformer</literal>, which allows you to create
      a linear pipeline of transformations. The following example demonstrates
      the use of a <literal moreinfo="none">ChainedTransformer</literal> to
      transform the contents of a <literal
      moreinfo="none">Collection</literal>:</para>

      <programlisting format="linespecific" id="I_5_tt242">import java.util.*;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.finctors.ChainedTransformer;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.ArrayUtils;
import org.apache.commons.lang.StringUtils;

// Create a transformer that multiplies a number by 10
Transformer multiplyTransform = new Transformer( ) {
    public Object transform(Object object) {
        Integer integer = (Integer) object;
            return new Integer( integer.intValue( ) * 10 );
    }
}

// Create a transformer that subtracts 20 from a number
Transformer subtractTransform = new Transformer( ) {
    public Object transform(Object object) {
        Integer integer = (Integer) object;
            return new Integer( integer.intValue( ) - 20 );
    }
}

<userinput moreinfo="none">// Chain the transformers together</userinput>
               <userinput moreinfo="none">Transformer transformChain = new ChainedTransformer( </userinput>
               <userinput moreinfo="none">    new Transformer[] { multiplyTransform, subtractTransform } );</userinput>

// Create a List of Integer objects
int[] array = new int[] { 1, 2, 3, 4, 5, 6, 7, 8 };
List intList = Arrays.asList( ArrayUtils.toObject( array ) );

<userinput moreinfo="none">CollectionUtils.transform( intList, transformChain );</userinput>

System.out.println( "Original: " + ArrayUtils.toString( array ) );
System.out.println( "Transformed: " + 
                    ArrayUtils.toString( intList.toArray( ) ) );</programlisting>

      <para>Two transformers, <literal
      moreinfo="none">multiplyTransform</literal> and <literal
      moreinfo="none">subtractTransform</literal>, are defined as anonymous
      inner classes, which implement the <literal
      moreinfo="none">Transformer</literal> interface. These two <literal
      moreinfo="none">Transformer</literal>s are combined in a <literal
      moreinfo="none">ChainedTransformer</literal>. An array of <literal
      moreinfo="none">int</literal> primitives is converted to an array of
      <literal moreinfo="none">Integer</literal> objects using <literal
      moreinfo="none">ArrayUtils.toObject( )</literal>. This object array is
      then converted to a <literal moreinfo="none">List</literal>, which is
      transformed using <literal moreinfo="none">CollectionUtils.transform(
      )</literal>. The transformation multiples each element by 10 and
      subtracts 20, producing the following output:</para>

      <programlisting format="linespecific" id="I_5_tt243">Original: 1, 2, 3, 4, 5, 6, 7, 8
Transformed: -10, 0, 10, 20, 30, 40, 50, 60</programlisting>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>In addition to the <literal
      moreinfo="none">ChainedTransformer</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2627" significance="normal">
          <primary>ChainedTransformer</primary>
        </indexterm>, there<indexterm class="endofrange"
      id="jakartackbk-CHP-5-ITERM-2628" significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2619"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2629"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2620"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2630"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2621"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2631"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2622"></indexterm> are a number of
      other useful <literal moreinfo="none">Transformer</literal>
      implementations that ship with Commons Collections. The <literal
      moreinfo="none">ChainedTransformer</literal> and other <literal
      moreinfo="none">Transformer</literal> implementations are discussed in
      depth in <link linkend="jakartackbk-CHP-4">Chapter 4</link>. For more
      information about the various implementations of <literal
      moreinfo="none">Transformer</literal>, see the Commons Collections
      project (<systemitem moreinfo="none"
      role="url">http://jakarta.apache.org/commons/collections</systemitem>).</para>
    </sect2>
  </sect1>

  <sect1 id="collections-sect-lru-cache" label="5.17" role="Recipe">
    <title>Creating a Least Recently Used Cache</title>

    <sect2>
      <title>Problem</title>

      <para>You need to present common data to many <indexterm
          id="jakartackbk-CHP-5-ITERM-2632" significance="normal">
          <primary>Commons Collections</primary>

          <secondary>caches</secondary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2633"
          significance="normal">
          <primary>collections</primary>

          <secondary>caches</secondary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2634"
          significance="normal">
          <primary>objects</primary>

          <secondary>Collections</secondary>

          <tertiary>caches</tertiary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2635"
          significance="normal">
          <primary>caches</primary>
        </indexterm>clients, and you want to cache this common data in a data
      structure of limited size, evicting the least recently used entry when
      the maximum size limit has been reached.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">LRUMap</literal>—a fixed size map
      that uses the least recently used algorithm to evict entries once the
      maximum size has been reached. The least recently used algorithm evicts
      the element that has not been used for the longest amount of time. The
      following example demonstrates the use of an <literal
      moreinfo="none">LRUMap</literal> to store stock quotes:</para>

      <programlisting format="linespecific" id="I_5_tt244">import java.util.Map;
import org.apache.commons.collections.map.LRUMap;

<userinput moreinfo="none">cache = new LRUMap( 5 );</userinput>
       
// Populate the cache with 5 stock prices
cache.put( "MSFT", new Float( 0.03 ) );
cache.put( "TSC", new Float( 0.001 ) );
cache.put( "LU", new Float( 23.30 ) );
cache.put( "CSCO", new Float( 242.20 ) );
cache.put( "P", new Float( 10.23 ) );
        
// Now use some of the entries in the cache
Float cscoPrice  = (Float) cache.get( "CSCO" );
Float msPrice = (Float) cache.get( "MSFT" );
Float tscPrice = (Float) cache.get( "TSC" );
Float luPrice = (Float) cache.get( "LU" );
Float pPrice = (Float) cache.get( "P" );
Float msPrice2 = (Float) cache.get( "MSFT" );
       
<userinput moreinfo="none">// Add another price to the Map, this should kick out the LRU item.</userinput>
               <userinput moreinfo="none">cache.put( "AA", new Float( 203.20 ) );</userinput>
               <userinput moreinfo="none">     </userinput>
               <userinput moreinfo="none">// CSCO was the first price requested, it is therefore the</userinput>
               <userinput moreinfo="none">// least recently used.</userinput>
               <userinput moreinfo="none">if( !cache.containsKey("CSCO") ) {</userinput>
               <userinput moreinfo="none">    System.out.println( "As expected CSCO was discarded" );</userinput>
               <userinput moreinfo="none">}</userinput>
            </programlisting>

      <para>Since the <literal moreinfo="none">LRUMap</literal> created in
      this example can only hold five elements, the "CSCO" quote is evicted
      when "AA" is added to the map because it is the "least recently
      used."</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>An <literal moreinfo="none">LRUMap</literal> is appropriate when a
      system presents common data to a number of clients. For example, if a
      web site displays breaking news stories, objects representing these
      stories can be stored in a size-limited cache with an LRU eviction
      policy, such as <literal moreinfo="none">LRUMap</literal>. Demand for
      objects that represent breaking news stories can be very time sensitive;
      many customers read the same story at the same time. Your application
      server has a size-limited <literal moreinfo="none">LRUMap</literal> that
      holds 100 news stories, and, when a new story is added, the <literal
      moreinfo="none">LRUMap</literal> evicts the stalest story in the
      <literal moreinfo="none">Map</literal>.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>The <literal moreinfo="none">LRUMap</literal> is an ideal solution
      for a cache, but, if your application needs to make heavy use of
      caching, take a look at the following open source cache
      implementations—OSCache or JCS. For more information about OSCache, see
      the OpenSymphony OSCache project page (<systemitem moreinfo="none"
      role="url">http://www.opensymphony.com/oscache/</systemitem>). The Java
      Caching System (JCS) was an offshoot of the Jakarta Turbine project; for
      more information about JCS, see the JCS project page (<systemitem
      moreinfo="none"
      role="url">http://jakarta.apache.org/turbine/jcs/</systemitem>).</para>
    </sect2>
  </sect1>

  <sect1 id="collections-sect-lazy-map" label="5.18" role="Recipe">
    <title>Using a Lazy Map</title>

    <sect2>
      <title>Problem</title>

      <para>You need a <literal moreinfo="none">Map</literal> that can
      <indexterm class="startofrange" id="jakartackbk-CHP-5-ITERM-2636"
          significance="normal">
          <primary>Commons Collections</primary>

          <secondary>lazy maps</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2637" significance="normal">
          <primary>collections</primary>

          <secondary>lazy maps</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2638" significance="normal">
          <primary>objects</primary>

          <secondary>Collections</secondary>

          <tertiary>lazy maps</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2639" significance="normal">
          <primary>lazy maps</primary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2640" significance="normal">
          <primary>mapping</primary>

          <secondary>lazy maps</secondary>
        </indexterm>populate a value <indexterm
          id="jakartackbk-CHP-5-ITERM-2641" significance="normal">
          <primary>populating</primary>

          <secondary>values</secondary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2642"
          significance="normal">
          <primary>values</primary>

          <secondary>populating</secondary>
        </indexterm>when its corresponding key is requested.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Decorate a <literal moreinfo="none">Map</literal> with <literal
      moreinfo="none">LazyMap</literal>. Attempting to retrieve a value with a
      key that is not in a <literal moreinfo="none">Map</literal> decorated
      with <literal moreinfo="none">LazyMap</literal> will trigger the
      creation of a value by a <literal moreinfo="none">Transformer</literal>
      associated with this <literal moreinfo="none">LazyMap</literal>. The
      following example decorates a <literal moreinfo="none">HashMap</literal>
      with a <literal moreinfo="none">Transformer</literal> that reverses
      strings; when a key is requested, a value is created and put into the
      <literal moreinfo="none">Map</literal> using this <literal
      moreinfo="none">Transformer</literal>:</para>

      <programlisting format="linespecific" id="I_5_tt245">import java.util.*;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.map.LazyMap;
import org.apache.commons.lang.StringUtils;

// Create a Transformer to reverse strings - defined below
Transformer reverseString = new Transformer( ) {
    public Object transform( Object object ) {
        String name = (String) object;
        String reverse = StringUtils.reverse( name );
        return reverse;
    }
}

// Create a LazyMap called lazyNames, which uses the above Transformer
Map names = new HashMap( );
<userinput moreinfo="none">Map lazyNames = LazyMap.decorate( names, reverseString );</userinput>

// Get and print two names
String name = (String) lazyNames.get( "Thomas" );
System.out.println( "Key: Thomas, Value: " + name );

name = (String) lazyNames.get( "Susan" );
System.out.println( "Key: Susan, Value: " + name );</programlisting>

      <para>Whenever <literal moreinfo="none">get( )</literal> is called, the
      decorated <literal moreinfo="none">Map</literal> passes the requested
      key to a <literal moreinfo="none">Transformer</literal>, and, in this
      case, a reversed string is put into a <literal
      moreinfo="none">Map</literal> as a value. The previous example requests
      two strings and prints the following output:</para>

      <programlisting format="linespecific" id="I_5_tt246">Key: Thomas, Value: samohT
Key: Susan, Value: nasuS</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para><literal moreinfo="none">LazyMap</literal> works best when a key
      is a symbol or an abbreviation for a more complex object. If you are
      working with a database, you could create a <literal
      moreinfo="none">LazyMap</literal> that retrieves objects by a primary
      key value; in this case, the <literal
      moreinfo="none">Transformer</literal> simply retrieves a record from a
      database table using the supplied key. Another example that springs to
      mind is a stock quote; in the stock exchange, a company is represented
      as a series of characters: "YHOO" represents the company Yahoo!, Inc.,
      and "TSC" represents TheStreet.com. If your system deals with a quote
      feed, use a <literal moreinfo="none">LazyMap</literal> to cache
      frequently used entries. <link linkend="jakartackbk-CHP-5-EX-17">Example
      5-17</link> uses a <literal moreinfo="none">LazyMap</literal> to create
      a cache populated on demand, and it also demonstrates the <literal
      moreinfo="none">LRUMap</literal>—a fixed-size implementation of the
      <literal moreinfo="none">Map</literal> introduced in <link
      linkend="jakartackbk-CHP-5-SECT-17">Recipe 5.17</link>.</para>

      <example id="jakartackbk-CHP-5-EX-17" label="5-17">
        <title>Example using a LazyMap</title>

        <programlisting format="linespecific">package com.discursive.jccook.collections.lazy;

import java.net.URL;
import java.util.Map;

import org.apache.commons.collections.map.LRUMap;
import org.apache.commons.collections.map.LazyMap;

public class LazyMapExample {

    Map stockQuotes;

    public static void main(String[] args) throws Exception {
        LazyMapExample example = new LazyMapExample( );
        example.start( );
    }
    
    public void start( ) throws Exception {
        
<userinput moreinfo="none">        StockQuoteTransformer sqTransformer = new StockQuoteTransformer( );</userinput>
                  <userinput moreinfo="none">        sqTransformer.setQuoteURL( new URL("http://quotes.company.com") );</userinput>
                  <userinput moreinfo="none">        sqTransformer.setTimeout( 500 );</userinput>
                  <userinput moreinfo="none"> </userinput>
                  <userinput moreinfo="none">        // Create a Least Recently Used Map with max size = 5       </userinput>
                  <userinput moreinfo="none">        stockQuotes = new LRUMap( 5 );</userinput>

                  <userinput moreinfo="none">        // Decorate the LRUMap with the StockQuoteTransformer</userinput>
                  <userinput moreinfo="none">        stockQuotes = LazyMap.decorate( stockQuotes, sqTransformer );</userinput>
        
        // Now use some of the entries in the cache
        Float price = (Float) stockQuotes.get( "CSCO" );
        price = (Float) stockQuotes.get( "MSFT" );
        price = (Float) stockQuotes.get( "TSC" );
        price = (Float) stockQuotes.get( "TSC" );
        price = (Float) stockQuotes.get( "LU" );
        price = (Float) stockQuotes.get( "P" );
        price = (Float) stockQuotes.get( "P" );
        price = (Float) stockQuotes.get( "MSFT" );
        price = (Float) stockQuotes.get( "LU" );
        
        // Request another price to the Map, this should kick out the LRU item.
        price = (Float) stockQuotes.get( "AA" );
        
        // CSCO was the first price requested, it is therefore the
        // least recently used.
        if( !stockQuotes.containsKey("CSCO") ) {
            System.out.println( "As expected CSCO was discarded" );
        }
    }
}</programlisting>
      </example>

      <para>The <literal moreinfo="none">Transformer</literal> in <link
      linkend="jakartackbk-CHP-5-EX-17">Example 5-17</link> is an object that
      takes a string and hits a URL using Jakarta HttpClient—a utility
      introduced in <link linkend="jakartackbk-CHP-11">Chapter 11</link>.
      Every time a new symbol is encountered, this <literal
      moreinfo="none">Transformer</literal> creates another thread with a
      timeout and hits a "quote server" that is configured to return the
      latest price for that company's symbol. <link
      linkend="jakartackbk-CHP-5-EX-18">Example 5-18</link> defines a <literal
      moreinfo="none">StockQuoteTransformer</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2643" significance="normal">
          <primary>StockQuoteTransformer</primary>
        </indexterm> that retrieves a quote by passing a stock symbol as a URL
      parameter.</para>

      <example id="jakartackbk-CHP-5-EX-18" label="5-18">
        <title>A StockQuoteTransformer</title>

        <programlisting format="linespecific">package com.discursive.jccook.collections.lazy;

import java.net.URL;

import org.apache.commons.collections.Transformer;
import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.HttpURL;
import org.apache.commons.httpclient.methods.GetMethod;

public class StockQuoteTransformer implements Transformer {

    protected URL quoteURL;
    protected long timeout;

    public Object transform(Object symbol) {
        QuoteRetriever retriever = new QuoteRetriever( (String) symbol );
        
        try {
            Thread retrieveThread = new Thread( retriever );
            retrieveThread.start( );
            retrieveThread.join( timeout );
        } catch( InterruptedException ie ) {
            System.out.println( "Quote request timed out.");
        }
        
        return retriever.getResult( );
    }

    public URL getQuoteURL( ) { return quoteURL; }
    public void setQuoteURL(URL url) { quoteURL = url; }

    public long getTimeout( ) { return timeout; }
    public void setTimeout(long l) { timeout = l; }
    
    public class QuoteRetriever implements Runnable {
        private String symbol;
        private Float result = new Float( Float.NaN );
        
        public QuoteRetriever(String symbol) {
            this.symbol = symbol;
        }
        
        public Float getResult( ) {
            return result;
        }
        
        public void run( ) {
            HttpClient client = new HttpClient( );
            try {
                HttpURL url = new HttpURL( quoteURL.toString( ) );
                url.setQuery( "symbol", symbol );
                
                GetMethod getMethod = new GetMethod( url.toString( ) );
                client.executeMethod( getMethod );
                String response = getMethod.getResponseBodyAsString( );
                
                result = new Float( response );
            } catch( Exception e ) {
                System.out.println( "Error retrieving quote" );
            }
        }
        
    }
}</programlisting>
      </example>

      <para>The point of this example is to demonstrate the power of
      decorating an <literal moreinfo="none">LRUMap</literal> with <literal
      moreinfo="none">LazyMap</literal> and to write a <literal
      moreinfo="none">Transformer</literal> that can fetch a piece of data
      from another server, not that the <literal
      moreinfo="none">StockQuoteTransformer</literal> uses Jakarta
      HttpClient.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>For more information about Jakarta HttpClient,<indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2644"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2636"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2645"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2637"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2646"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2638"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2647"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2639"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2648"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2640"></indexterm> see <link
      linkend="jakartackbk-CHP-11">Chapter 11</link>. For more information
      about the <literal moreinfo="none">LRUMap</literal>, see <link
      linkend="jakartackbk-CHP-5-SECT-17">Recipe 5.17</link>.</para>
    </sect2>
  </sect1>

  <sect1 id="collections-sect-counting" label="5.19" role="Recipe">
    <title>Counting Objects in a Collection</title>

    <sect2>
      <title>Problem</title>

      <para>You need to count the number <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2649" significance="normal">
          <primary>Commons Collections</primary>

          <secondary>counting</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2650" significance="normal">
          <primary>collections</primary>

          <secondary>counting</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2651" significance="normal">
          <primary>objects</primary>

          <secondary>Collections</secondary>

          <tertiary>counting</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2652" significance="normal">
          <primary>counting objects in collections</primary>
        </indexterm>of times an object occurs in a <literal
      moreinfo="none">Collection</literal>.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">CollectionUtils</literal> methods
      <literal moreinfo="none">countMatches()</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2653" significance="normal">
          <primary>countMatches( ) method</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2654"
          significance="normal">
          <primary>methods</primary>

          <secondary>countMatches( )</secondary>
        </indexterm> or <literal moreinfo="none">cardinality()</literal>
      <indexterm id="jakartackbk-CHP-5-ITERM-2655" significance="normal">
          <primary>cardinality( ) method</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2656"
          significance="normal">
          <primary>methods</primary>

          <secondary>cardinality( )</secondary>
        </indexterm>. <literal moreinfo="none">countMatches( )</literal> takes
      a <literal moreinfo="none">Collection</literal> and a <literal
      moreinfo="none">Predicate</literal>, returning the number of elements
      that satisfy that <literal moreinfo="none">Predicate</literal>. <literal
      moreinfo="none">cardinality( )</literal> takes an <literal
      moreinfo="none">Object</literal> and a <literal
      moreinfo="none">Collection</literal>, returning the number of items
      equal to the supplied <literal moreinfo="none">Object</literal>. The
      following example demonstrates the use of both methods to count the
      number of times an <literal moreinfo="none">Object</literal> occurs in a
      <literal moreinfo="none">Collection</literal>:</para>

      <programlisting format="linespecific" id="I_5_tt247">import java.util.*;
import org.apache.commons.collections.Predicate;
import org.apache.commons.collections.functors.EqualPredicate;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.ArrayUtils;

String[] array = new String[] { "A", "B", "C", "C", "B", "B" };
List stringList = Arrays.asList( array );

Predicate equalPredicate = new EqualPredicate("C");

<userinput moreinfo="none">int numberCs = CollectionUtils.countMatches( stringList, equalsPredicate );</userinput>
               <userinput moreinfo="none">int numberBs = CollectionUtils.cardinality( "B", stringList );</userinput>

System.out.println( "List: " + ArraUtils.toString( array ) );
System.out.println( "Number of Cs: " + numberCs );
System.out.println( "Number of Bs: " + numberBs );</programlisting>

      <para>When used with the <literal
      moreinfo="none">EqualPredicate</literal>, <literal
      moreinfo="none">countMatches( )</literal> performs the same function as
      <literal moreinfo="none">cardinality( )</literal>. This example produces
      the following output.</para>

      <programlisting format="linespecific" id="I_5_tt248">List: A, B, C, C, B, B
Number of Cs: 2
Number of Bs: 3</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para><literal moreinfo="none">countMatches( )</literal> is not limited
      to counting the number of elements in a <literal
      moreinfo="none">Collection</literal> equal to an object; this method can
      also be used to count objects that meet any arbitrary <literal
      moreinfo="none">Predicate</literal>. For example, you could count the
      number of elements in a list that match a composite predicate or a
      custom predicate. The following example demonstrates the use of <literal
      moreinfo="none">countMatches( )</literal> to count the number of objects
      that match a custom predicate:</para>

      <programlisting format="linespecific" id="I_5_tt249">import java.util.*;
import org.apache.commons.collections.Predicate;
import org.apache.commons.collections.functors.EqualPredicate;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.ArrayUtils;

int[] array = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
List intList = Arrays.asList( ArrayUtils.toObject( array ) );

Predicate isEvenPredicate = new Predicate( ) {
    public boolean evaluate(Object object) {
        Integer value = (Integer) object;
        return ( (value.intValue( ) % 2) == 0 );
    }
}

int numberEven = CollectionUtils.countMatches( intList, isEvenPredicate );

System.out.println( "List: " + ArrayUtils.toString( array ) );
System.out.println( "Number of Even Numbers: " + numberEven );</programlisting>

      <para>This example counts the number of even numbers in a <literal
      moreinfo="none">Collection</literal>; the <literal
      moreinfo="none">isEvenPredicate</literal> is an anonymous inner class
      that implements the <literal moreinfo="none">Predicate</literal>
      interface. This <literal moreinfo="none">Predicate</literal> is passed
      to <literal moreinfo="none">CollectionUtils.countMatches( )</literal>,
      producing the following output:</para>

      <programlisting format="linespecific" id="I_5_tt250">List: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
Number of Even Numbers: 5</programlisting>

      <para><literal moreinfo="none">CollectionUtils</literal> can also return
      a frequency <literal moreinfo="none">Map</literal> for every object in a
      <literal moreinfo="none">Collection</literal>; calling <literal
      moreinfo="none">CollectionUtils.getCardinalityMap( )</literal> returns
      such a <literal moreinfo="none">Map</literal>. The keys of this <literal
      moreinfo="none">Map</literal> are the distinct objects in the <literal
      moreinfo="none">Collection</literal>, and the values are <literal
      moreinfo="none">Integer</literal> objects representing the number of
      times each object appears in the <literal
      moreinfo="none">Collection</literal>. The following example demonstrates
      the creation of a frequency <literal moreinfo="none">Map</literal> from
      a list of strings:</para>

      <programlisting format="linespecific" id="I_5_tt251">import java.util.*;
import org.apache.commons.collections.Predicate;
import org.apache.commons.collections.functors.EqualPredicate;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.ArrayUtils;

String[] array = new String[] { "Red", "Blue", "Blue", "Yellow", "Red", 
"Black" };
List stringList = Arrays.asList( arrays );

Map cardinalityMap = CollectionUtils.getCardinalityMap( stringList );

System.out.println( "List: " + ArrayUtils.toString( array ) );
System.out.println( "Cardinality Map:\n" + MapUtils.
debugPrint( cardinalityMap ) );</programlisting>

      <para>A <literal moreinfo="none">String</literal> array is converted to
      a <literal moreinfo="none">List</literal> of strings, and a frequency
      <literal moreinfo="none">Map</literal> is created. This <literal
      moreinfo="none">Map</literal> is printed using <literal
      moreinfo="none">MapUtils.debugPrint( )</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2657" significance="normal">
          <primary>MapUtils.debugPrint( ) method</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2658"
          significance="normal">
          <primary>methods</primary>

          <secondary>MapUtils.debugPrint( )</secondary>
        </indexterm>:</para>

      <programlisting format="linespecific" id="I_5_tt252">List: Red, Blue, Blue, Yellow, Red, Black
Cardinality Map:
{
    Red = 3
    Blue = 2
    Yellow = 1
    Black = 1
}</programlisting>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>If you are interested in the cardinality of objects in a <literal
      moreinfo="none">Collection</literal>, consider using a <literal
      moreinfo="none">Bag</literal>. A <literal moreinfo="none">Bag</literal>
      is a <literal moreinfo="none">Collection</literal> that revolves around
      the<indexterm class="endofrange" id="jakartackbk-CHP-5-ITERM-2659"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2649"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2660"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2650"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2661"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2651"></indexterm> <indexterm
      class="endofrange" id="jakartackbk-CHP-5-ITERM-2662"
      significance="normal"
      startref="jakartackbk-CHP-5-ITERM-2652"></indexterm> cardinality of
      objects it contains. <literal moreinfo="none">Bag</literal> objects are
      described in <link linkend="jakartackbk-CHP-5-SECT-6">Recipe
      5.6</link>.</para>
    </sect2>
  </sect1>

  <sect1 id="collections-sect-performing-set" label="5.20" role="Recipe">
    <title>Performing Set Operations</title>

    <sect2>
      <title>Problem</title>

      <para>You need to perform set operations <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2663" significance="normal">
          <primary>Commons Collections</primary>

          <secondary>set operations</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2664" significance="normal">
          <primary>collections</primary>

          <secondary>set operations</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2665" significance="normal">
          <primary>objects</primary>

          <secondary>Collections</secondary>

          <tertiary>set operations</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2666" significance="normal">
          <primary>set operations</primary>
        </indexterm>to find the <indexterm id="jakartackbk-CHP-5-ITERM-2667"
          significance="normal">
          <primary>unions, collections</primary>
        </indexterm>union, <indexterm id="jakartackbk-CHP-5-ITERM-2668"
          significance="normal">
          <primary>intersections, collections</primary>
        </indexterm>intersection, <indexterm id="jakartackbk-CHP-5-ITERM-2669"
          significance="normal">
          <primary>disjunctions, collections</primary>
        </indexterm>disjunction, and difference of two collections.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use one of four <literal moreinfo="none">CollectionUtils</literal>
      methods to perform set operations—<literal moreinfo="none">union(
      )</literal>, <literal moreinfo="none">intersection( )</literal>,
      <literal moreinfo="none">disjunction()</literal>, and <literal
      moreinfo="none">subtract( )</literal> <indexterm
          id="jakartackbk-CHP-5-ITERM-2670" significance="normal">
          <primary>subtract( ) method</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2671"
          significance="normal">
          <primary>methods</primary>

          <secondary>subtract( )</secondary>
        </indexterm>. <link linkend="jakartackbk-CHP-5-EX-19">Example
      5-19</link> demonstrates the use of these four methods with two <literal
      moreinfo="none">Collection</literal>s.</para>

      <example id="jakartackbk-CHP-5-EX-19" label="5-19">
        <title>Using CollectionUtils union( ), intersection( ), disjunction(
        ), and subtract( )</title>

        <programlisting format="linespecific">import java.util.*;

String[] arrayA = new String[] { "1", "2", "3", "3", "4", "5" };
String[] arrayB = new String[] { "3", "4", "4", "5", "6", "7" };

List a = Arrays.asList( arrayA );
List b = Arrays.asList( arrayB );

<userinput moreinfo="none">Collection union = CollectionUtils.union( a, b );</userinput>
                  <userinput moreinfo="none">Collection intersection = CollectionUtils.intersection( a, b );</userinput>
                  <userinput moreinfo="none">Collection disjunction = CollectionUtils.disjunction( a, b );</userinput>
                  <userinput moreinfo="none">Collection subtract = CollectionUtils.subtract( a, b );</userinput>

Collections.sort( union );
Collections.sort( intersection );
Collections.sort( disjunction );
Collections.sort( subtract );

System.out.println( "A: " + ArrayUtils.toString( a.toArray( ) ) );
System.out.println( "B: " + ArrayUtils.toString( b.toArray( ) ) );
System.out.println( "Union: " + ArrayUtils.toString( union.toArray( ) ) );
System.out.println( "Intersection: " + 
                    ArrayUtils.toString( intersection.toArray( ) ) );
System.out.println( "Disjunction: " + 
                    ArrayUtils.toString( disjunction.toArray( ) ) );
System.out.println( "Subtract: " + ArrayUtils.toString( subtract.toArray( ) ) );</programlisting>
      </example>

      <para>The previous example performs these four operations on two
      <literal moreinfo="none">List</literal> objects, <literal
      moreinfo="none">a</literal> and <literal moreinfo="none">b</literal>,
      printing the results with <literal moreinfo="none">ArrayUtils.toString(
      )</literal>:</para>

      <programlisting format="linespecific" id="I_5_tt253">A: {1,2,2,2,3,3,4,5}
B: {3,4,4,5,6,7}
Union: {1,2,2,2,3,3,4,4,5,6,7}
Intersection: {3,4,5}
Disjunction: {1,2,2,2,3,4,6,7}
Subtract: {1,2,2,2,3}</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Pay close attention to how these four functions deal with
      cardinality. These four set operations on <literal
      moreinfo="none">CollectionUtils</literal>—<literal
      moreinfo="none">union( )</literal>, <literal
      moreinfo="none">intersection( )</literal>, <literal
      moreinfo="none">disjunction( )</literal>, and <literal
      moreinfo="none">subtraction( )</literal>—all respect the cardinality of
      objects in both <literal moreinfo="none">Collection</literal>s. Take,
      for example, the results of the union of <literal
      moreinfo="none">a</literal> and <literal moreinfo="none">b</literal> in
      the Solution; the union of <literal moreinfo="none">a</literal> and
      <literal moreinfo="none">b</literal> contains two "3" elements and two
      "4" elements. The cardinality of an element in a union is the maximum
      cardinality of the element in both <literal
      moreinfo="none">Collection</literal>s. On the other hand, the
      cardinality of an element in an intersection is the minimum cardinality
      of the element in both <literal moreinfo="none">Collection</literal>s;
      there is only one "3" element and one "4" element in the intersection of
      <literal moreinfo="none">a</literal> and <literal
      moreinfo="none">b</literal>.</para>

      <para><link linkend="jakartackbk-CHP-5-FIG-3">Figure 5-3</link>
      illustrates each set operation with a Venn diagram. "A union B" is the
      combination of A and B, and "A intersection B" is the common overlap of
      A and B. "A subtract B" is all elements only in A, and "A disjunction B"
      is all elements in either A or B but not both.</para>

      <figure float="0" id="jakartackbk-CHP-5-FIG-3" label="5-3">
        <title>Venn diagrams for four set operations in
        CollectionUtils</title>

        <mediaobject id="I_5_tt254">
          <imageobject role="print">
            <imagedata depth="188" fileref="figs/print/jccb_0503.pdf"
                       format="PDF" width="202" />
          </imageobject>

          <imageobject role="web">
            <imagedata depth="188" fileref="figs/web/jccb_0503.png"
                       format="PNG" width="202" />
          </imageobject>
        </mediaobject>
      </figure>
    </sect2>
  </sect1>

  <sect1 id="collections-sect-retrieving-casting" label="5.21" role="Recipe">
    <title>Retrieving Map Values Without Casting</title>

    <sect2>
      <title>Problem</title>

      <para>You need to retrieve a primitive<indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2676" significance="normal">
          <primary>Commons Collections</primary>

          <secondary>casting</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2677" significance="normal">
          <primary>collections</primary>

          <secondary>casting</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2678" significance="normal">
          <primary>objects</primary>

          <secondary>Collections</secondary>

          <tertiary>casting</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2679" significance="normal">
          <primary>casting</primary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2680" significance="normal">
          <primary>mapping</primary>

          <secondary>casting</secondary>
        </indexterm> <indexterm class="startofrange"
          id="jakartackbk-CHP-5-ITERM-2681" significance="normal">
          <primary>values</primary>

          <secondary>casting</secondary>
        </indexterm> <literal moreinfo="none">double</literal> from a <literal
      moreinfo="none">Map</literal>, but the value is stored as a <literal
      moreinfo="none">Double</literal> object.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">MapUtils.getDoubleValue()</literal>
      <indexterm id="jakartackbk-CHP-5-ITERM-2682" significance="normal">
          <primary>MapUtils.getDoubleValue( ) method</primary>
        </indexterm> <indexterm id="jakartackbk-CHP-5-ITERM-2683"
          significance="normal">
          <primary>methods</primary>

          <secondary>mapUtils.getDoubleValue( )</secondary>
        </indexterm> to retrieve a <literal moreinfo="none">Double</literal>
      object from a <literal moreinfo="none">Map</literal> as a <literal
      moreinfo="none">double</literal> primitive. The following example
      demonstrates <literal moreinfo="none">getDoubleValue(
      )</literal>:</para>

      <programlisting format="linespecific" id="I_5_tt255">import java.util.*;
import org.apache.commons.lang.ArrayUtils;
import org.apache.commons.collections.MapUtils;

Object[] mapArray = new Object[][] {
    { "A", new Double( 2.0 ) },
    { "B", new Double( 0.223242 ) },
    { "C", new Double( 2828e4 ) },
    { "D", "GARBAGE"} };

Map numberMap = ArrayUtils.toMap( mapArray );

double a = MapUtils.getDoubleValue( numberMap, "A" );
double b = MapUtils.getDoubleValue( numberMap, "B" );
double c = MapUtils.getDoubleValue( numberMap, "C" );
double d = MapUtils.getDoubleValue( numberMap, "D", new Double( Double.NaN ) );

System.out.println( "A = " + a );
System.out.println( "B = " + b );
System.out.println( "C = " + c );
System.out.println( "D = " + d );</programlisting>

      <para>This simple utility retrieves four doubles from <literal
      moreinfo="none">numberMap</literal>; the fourth call to <literal
      moreinfo="none">getDoubleValue( )</literal> supplies a default <literal
      moreinfo="none">double</literal> to be returned if the value's type
      cannot be converted to a <literal moreinfo="none">double</literal>. This
      example produces the following output:</para>

      <programlisting format="linespecific" id="I_5_tt256">A = 2.0
B = 0.223242
C = 28280.0
D = NaN</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>This utility is laughably simple, but if you are working with
      numbers, this utility can help you avoid casting and calling <literal
      moreinfo="none">doubleValue( )</literal>. In addition to <literal
      moreinfo="none">MapUtils.getDoubleValue( )</literal>, <literal
      moreinfo="none">MapUtils</literal> also contains the <literal
      moreinfo="none">MapUtils.getDouble( )</literal> method, which simply
      returns a <literal moreinfo="none">Double</literal> object. The
      following example demonstrates the various utility methods for obtaining
      primitives and their corresponding object types from a <literal
      moreinfo="none">Map</literal>:</para>

      <programlisting format="linespecific" id="I_5_tt257">import java.util.*;
import org.apache.commons.collections.MapUtils;

Map map = new HashMap( );
map.put( "A", new Long( 3.4 ) );
map.put( "B", new Short( 33 ) );
map.put( "C", "BLAH" );

Number aNumber = MapUtils.getNumber( map, "A" );
Long aLong = MapUtils.getLong( map, "A" );

long a = MapUtils.getLongValue( map, "A" );
short b = MapUtils.getShortValue( map, "B" );
Byte c = MapUtils.getByte( map, "C", Byte.MAX_VALUE );</programlisting>

      <para>As shown in the previous example, <literal
      moreinfo="none">MapUtils</literal> contains utility methods for working
      with <literal moreinfo="none">bytes</literal>, <literal
      moreinfo="none">shorts</literal>, and <literal
      moreinfo="none">long</literal>, among other primitive types.</para>

      <para><link linkend="jakartackbk-CHP-5-TABLE-1">Table 5-1</link> details
      several related methods for <literal moreinfo="none">Boolean</literal>,
      <literal moreinfo="none">Double</literal>, and <literal
      moreinfo="none">Number</literal>, which can retrieve objects and
      primitive values from a <literal moreinfo="none">Map</literal>. While
      <link linkend="jakartackbk-CHP-5-TABLE-1">Table 5-1</link> deals with
      <literal moreinfo="none">Boolean</literal> and <literal
      moreinfo="none">Double</literal>, you should be aware that similar
      methods exist for all primitive types and corresponding objects.</para>

      <table id="jakartackbk-CHP-5-TABLE-1" label="5-1">
        <title>Methods on MapUtils</title>

        <tgroup cols="2">
          <colspec colname="col1" colnum="1" />

          <colspec colname="col2" colnum="2" />

          <thead>
            <row>
              <entry><para>Return type</para></entry>

              <entry><para>Signature</para></entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para> <literal moreinfo="none">Boolean</literal>
              </para></entry>

              <entry><para> <literal moreinfo="none">getBoolean(Map map,
              Object key)getBoolean(Map map, Object key, Boolean
              default)</literal> </para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">boolean</literal>
              </para></entry>

              <entry><para> <literal moreinfo="none">getBooleanValue(Map map,
              Object key)getBooleanBalue(Map map, Object key, boolean
              default)</literal> </para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">Double</literal>
              </para></entry>

              <entry><para> <literal moreinfo="none">getDouble(Map map, Object
              key)getDouble(Map map, Object key, Double default)</literal>
              </para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">double</literal>
              </para></entry>

              <entry><para> <literal moreinfo="none">getDoubleValue(Map map,
              Object key)getDoubleValue(Map map, Object key, double
              default)</literal> </para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">Number</literal>
              </para></entry>

              <entry><para> <literal moreinfo="none">getNumber(Map map, Object
              key)getNumber(Map map, Object key, Number default)</literal>
              <indexterm class="endofrange" id="jakartackbk-CHP-5-ITERM-2684"
              significance="normal"
              startref="jakartackbk-CHP-5-ITERM-2676"></indexterm> <indexterm
              class="endofrange" id="jakartackbk-CHP-5-ITERM-2685"
              significance="normal"
              startref="jakartackbk-CHP-5-ITERM-2677"></indexterm> <indexterm
              class="endofrange" id="jakartackbk-CHP-5-ITERM-2686"
              significance="normal"
              startref="jakartackbk-CHP-5-ITERM-2678"></indexterm> <indexterm
              class="endofrange" id="jakartackbk-CHP-5-ITERM-2687"
              significance="normal"
              startref="jakartackbk-CHP-5-ITERM-2679"></indexterm> <indexterm
              class="endofrange" id="jakartackbk-CHP-5-ITERM-2688"
              significance="normal"
              startref="jakartackbk-CHP-5-ITERM-2680"></indexterm> <indexterm
              class="endofrange" id="jakartackbk-CHP-5-ITERM-2689"
              significance="normal"
              startref="jakartackbk-CHP-5-ITERM-2681"></indexterm>
              </para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect2>
  </sect1>
</chapter>