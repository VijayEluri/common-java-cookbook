<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://mars.discursive.com/docbook/xml/4.5/docbookx.dtd">
<chapter id="proto">
  <title>Protocol Buffers</title>

  <sect1 id="proto-sect-intro">
    <title>Introduction</title>

    <sect2>
      <title>What is Protocol Buffers?</title>

      <para>Protocol Buffers is a library that allows you to encode structured
      data. It is primarily used in data exchange and RPC calls. It is an open
      source project created by Google and it is currently one of the most
      efficient ways to encode, transfer, and decode data in an application.
      It takes into account versioning of data elements and provides libraries
      to parse data in Java, C++, or Python.</para>

      <para>If you've been developing systems that encode data you've likely
      been serializing and deserializing XML or JSON documents, and using
      simple REST services or more complex SOAP services to enable
      interoperability between components in a heterogeneous architecture.
      Using a tool like protocol buffers to encode and decode data into
      binary, only makes sense if you understand the motivation behind the
      tool, the context in which it was created. The development of an
      efficient binary protocol for data interchange makes sense if you look
      at the progression of scalable systems in the last decade. </para>
    </sect2>

    <sect2>
      <title>The Evolution of Internet-scale Architecture</title>

      <para>Consider the architecture of a system designed to handle traffic
      at a large-scale, consumer-facing web in the year 2000 as shown in <xref
      linkend="proto-fig-old-system" />. Most large sites were still
      implemented using multiple application servers communicating with large
      relational databases. When an organization needed to scale such an
      architecture it would usually involve investing in more powerful
      hardware or starting to invest in technology to cache data at the
      application server layer. If you needed to scale such an architecture,
      you would scale horizontally by adding more application servers in
      parallel and spending more money to acquire more and more horsepower for
      your database server. The beginning of the last decade was all about
      massive relational databases and a very straightforward "N-tiered"
      approach to architecture.</para>

      <figure float="0" id="proto-fig-old-system">
        <title>Internet-scale Architecture from 2000</title>

        <mediaobject>
          <imageobject role="print">
            <imagedata align="center"
                       fileref="figs/print/proto-old-system.pdf" format="PDF"
                       scalefit="0" width="100%" />
          </imageobject>

          <imageobject role="web">
            <imagedata fileref="figs/web/proto-old-system.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Fast forward ten years, and we're in a completely different
      technology landscape. An architecture which would have called for 15
      very expensive machines in 2000, has morphed in an architecture which
      relies on hundreds or thousands of low-cost servers as shown in <xref
      linkend="proto-fig-modern-system" />. In 2000, your application likely
      read from a database and nothing else. In 2010, your internet-scale
      application uses NoSQL technologies such as Cassandra and solves complex
      problems offline using massive, on-demand Hadoop clusters or Amazon AWS
      to run Map/Reduce jobs.</para>

      <para>In 2000, you didn't have to worry about protocols. Your web
      servers communicated with your application servers using either AJP or
      just acted as HTTP proxies, and your applications retrieved and stored
      data in a database using a JDBC connection. In 2010, you are caching
      objects in memory, you are creating massive lookup tables in a memcached
      server to support sharding, and you are often looking to pass
      information and messages between disparate systems in a heterogeneous
      architecture.</para>

      <para>In summary, internet-scale architectures involve hundreds of
      machines and are usually very data intensive. Compared to 2000, an
      internet-scale application in 2010 has a lot more moving parts: more
      caching, more communications, more activity. The other big difference
      between the Internet-scale architecture of 2000 and 2010 is variety. In
      2000, your entire architecture was on a single platform such as J2EE or
      .NET. In 2010, your web application might be in Python while your
      high-performance Map/Reduce cluster might execute Java code, and your
      mobile applications are written in ObjectiveC. </para>

      <figure float="0" id="proto-fig-modern-system">
        <title>Internet-scale Architecture in 2010</title>

        <mediaobject>
          <imageobject role="print">
            <imagedata align="center"
                       fileref="figs/print/proto-modern-system.pdf"
                       format="PDF" scalefit="0" width="100%" />
          </imageobject>

          <imageobject role="web">
            <imagedata fileref="figs/web/proto-modern-system.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
    </sect2>

    <sect2>
      <title>Google's Solution: Polyglot Binary Format</title>

      <para>Given the transformation described in the previous section, what
      do you do when you have thousands of servers, each running components
      written in a handful of programming languages which need to parse
      Terabytes of data in a few hours?</para>

      <para>Google's answer: Protocol Buffers. </para>
    </sect2>

    <sect2>
      <title>The Importance of Small Things</title>

      <para>More and more developers are starting take advantage of some of
      the research that has enabled companies like Google and Amazon to
      achieve what Alex Payne calls "Scalability in the Large". Here is Payne
      on scalability as a "competitive advantage":</para>

      <blockquote>
        <para>"When you’re operating at scale, pushing the needle means a
        complex, coordinated dance of well-applied technologies, development
        techniques, statistical analyses, intra-organizational communication,
        judicious engineering management, speedy and reliable
        operationalization of hardware and software, vigilant monitoring, and
        so forth. Scaling is hard. So hard, in fact, that the ability to scale
        is a deep competitive advantage of the sort that you can’t simply go
        out and download, copy, purchase, or steal." - Alex Payne "Node and
        Scaling in the Small vs Scaling in the Large"<footnote>
            <para>Alex Payne, "Node and Scaling in the Small vs. Scaling in
            the Large," <emphasis>Online Writing</emphasis>, <ulink
            url="http://al3x.net/2010/07/27/node.html">http://al3x.net/2010/07/27/node.html</ulink>
            (last visited 31 July 2010).</para>
          </footnote></para>
      </blockquote>

      <para>Google's Protocol Buffers might seem like an insignificant little
      IDL tool, but it is an important part of Google's "competitive
      advantage". It is one of the fundamental messaging technology that
      allows Google to efficiently process Petabytes of information in
      seconds. Coincidentally, Payne's former employer, Twitter, also uses
      Protocol Buffers as a format in its Hadoop-based analytics work<footnote>
          <para>http://www.slideshare.net/kevinweil/protocol-buffers-and-hadoop-at-twitter</para>
        </footnote>.</para>
    </sect2>
  </sect1>

  <sect1 id="proto-sect-downloading">
    <title>Downloading Protocol Buffers</title>

    <sect2>
      <title>Problem</title>

      <para>You need to download Protocol Buffers.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>If you are using a Mac OSX or a Linux machine, you should download
      the full source distribution of Protocol Buffers and compile the tool
      locally. If you are using a Windows machine, you can download a
      precompiled version of the Protocol Buffers </para>

      <para>To download Protocol Buffers, go to the Google Code project for
      Protocol Buffers at <ulink
      url="???">http://code.google.com/p/protobuf/</ulink>. Once you've loaded
      this site in a browser, click on one of the featured downloads on the
      right side of the page as shown in <xref
      linkend="proto-fig-site" />.</para>

      <figure float="0" id="proto-fig-site">
        <title>Downloading Protocol Buffers Source</title>

        <mediaobject>
          <imageobject role="print">
            <imagedata align="center" fileref="figs/print/proto-site.pdf"
                       format="PDF" scalefit="0" width="100%" />
          </imageobject>

          <imageobject role="web">
            <imagedata fileref="figs/web/proto-site.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <sect3>
        <title>Linux or Mac OSX Installation</title>

        <para>Download the full source distribution for Protocol Buffers.
        Click on the protobuf-2.0.3.tar.gz file shown in <xref
        linkend="proto-fig-site" /> and save this file to your computer. Next,
        proceed to the next section, <xref
        linkend="proto-sect-compiling" />.</para>
      </sect3>

      <sect3>
        <title>Windows Installation</title>

        <para>On a Windows machine, download
        <filename>protoc-2.3.0-win32.zip</filename> and unzip the archive.
        This win32 distribution contains two files
        <filename>README.txt</filename> and <filename>protoc.exe</filename>.
        Unzip the archive and put the <filename>protoc.exe</filename> compiler
        in your operating system's <varname>PATH</varname>.</para>

        <screen>C:\Users\tobrien\Downloads:&gt; <command>unzip protoc-2.3.0-win32.zip</command> 
Archive:  protoc-2.3.0-win32.zip
  inflating: readme.txt              
  inflating: protoc.exe </screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="proto-sect-compiling">
    <title>Compiling Protocol Buffers</title>

    <sect2>
      <title>Problem</title>

      <para>You have downloaded the Protocol Buffers source distribution and
      you need to compile the <filename>protoc</filename> compiler. </para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>If you've downloaded the Protocol Buffers source distribution to a
      Mac OSX machine, you will need to install Apple Xcode. The Xcode is
      packaged with a number of utilities including GCC. Apple's Xcode is
      available from Apple here <ulink
      url="http://developer.apple.com/technologies/tools/xcode.html">http://developer.apple.com/technologies/tools/xcode.html</ulink>.
      </para>

      <para>If you've downloaded the Protocol Buffers source distribution to a
      Linux machine, you will need to install the GCC compiler and Make.
      </para>

      <note>
        <para>If you are using Protocol Buffers on a Windows platform, you
        should just download the binary distribution of the protoc.exe
        compiler as shown in <xref linkend="proto-sect-downloading" />.</para>
      </note>

      <para>The source distribution can be configured, built, and installed
      using the following sequence of commands:</para>

      <screen>~/Downloads/protobuf-2.3.0 $ <command>./configure</command>
checking build system type... i386-apple-darwin10.4.0
checking host system type... i386-apple-darwin10.4.0
checking target system type... i386-apple-darwin10.4.0
...
~/Downloads/protobuf-2.3.0 $ <command>make</command>
make  all-recursive
Making all in .
make[2]: Nothing to be done for `all-am'.
Making all in src
~/Downloads/protobuf-2.3.0 $ <command>sudo make install</command>
Password:
Making install in .
...
</screen>

      <para>First, run <command>./configure</command> to check your system for
      required tools and libraries. Then run <command>make</command> to
      compile the Protocol Buffers tool. Running make will take a few minutes.
      After you have successfully compiled Protocol Buffers, install it by
      running <command>make install</command>. Since installation requires
      administrative privileges, run <command>sudo make install</command> to
      run make as an administrative user.</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>To test that the Protocol Buffers compiler was successfully
      installed, run <command>protoc --help</command>. Running this command
      should produce the </para>

      <screen>~ $ <command>protoc --help</command>
Usage: protoc [OPTION] PROTO_FILES
Parse PROTO_FILES and generate output based on the options given:
  -IPATH, --proto_path=PATH   Specify the directory in which to search for
                              imports.  May be specified multiple times;
                              directories will be searched in order.  If not
                              given, the current working directory is used.
  --version                   Show version info and exit.
  -h, --help                  Show this text and exit.
  --encode=MESSAGE_TYPE       Read a text-format message of the given type
                              from standard input and write it in binary
                              to standard output.  The message type must
                              be defined in PROTO_FILES or their imports.
  --decode=MESSAGE_TYPE       Read a binary message of the given type from
                              standard input and write it in text format
                              to standard output.  The message type must
                              be defined in PROTO_FILES or their imports.
  --decode_raw                Read an arbitrary protocol message from
                              standard input and write the raw tag/value
                              pairs in text format to standard output.  No
                              PROTO_FILES should be given when using this
                              flag.
  -oFILE,                     Writes a FileDescriptorSet (a protocol buffer,
    --descriptor_set_out=FILE defined in descriptor.proto) containing all of
                              the input files to FILE.
  --include_imports           When using --descriptor_set_out, also include
                              all dependencies of the input files in the
                              set, so that the set is self-contained.
  --error_format=FORMAT       Set the format in which to print errors.
                              FORMAT may be 'gcc' (the default) or 'msvs'
                              (Microsoft Visual Studio format).
  --plugin=EXECUTABLE         Specifies a plugin executable to use.
                              Normally, protoc searches the PATH for
                              plugins, but you may specify additional
                              executables not in the path using this flag.
                              Additionally, EXECUTABLE may be of the form
                              NAME=PATH, in which case the given plugin name
                              is mapped to the given executable even if
                              the executable's own name differs.
  --cpp_out=OUT_DIR           Generate C++ header and source.
  --java_out=OUT_DIR          Generate Java source file.
  --python_out=OUT_DIR        Generate Python source file.</screen>
    </sect2>
  </sect1>

  <sect1>
    <title>Defining a Message Type</title>

    <sect2>
      <title>Problem</title>

      <para>You need to define a message type that will allow you to encode
      data.</para>

      <para>Assume that you are working for a new startup called Checkin which
      is trying to create a system to track the status of every vehicle on the
      road. They've signed a deal with a large car manufacturer to install a
      mobile device which will communicate a car's status and position every
      five minutes. Since you expect more than ten million registered vehicles
      in the first year of operation, you want need to create a polling format
      that is going to scale and leave some flexibility for future
      changes.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Create a file called <filename>checkin.proto</filename> and define
      all of the message types in this file using the protocol buffer
      language.</para>

      <example>
        <title>A Protocol Buffers Message Definition</title>

        <programlisting>package com.discursive.cjcook.proto;
message PositionData {
  required uint32 vehicle_id = 1;
  optional float latitude = 2;
  optional float longitude = 3;
  optional float altitude = 4 [default = 0];
  optional int32 speed = 5;
  optional uint64 timestamp = 6;
  optional string status = 7;
}
</programlisting>
      </example>

      <para>To generate a Java class for this message type, run the
      <command>protoc</command> compiler:</para>

      <screen>~/projects/checking/src/main/java $ <command>protoc checkin.proto --java_out=.</command></screen>

      <para>Running the compiler against this definition will create a class
      named <classname>Checkin</classname> in the package
      <package>com.discursive.cjcook.proto</package>.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Measuring Protocol Buffers Performance</title>

    <sect2>
      <title>Problem</title>

      <para>You need to justify the use of Protocol Buffers and compare the
      performance of generating and parsing a Protocl Buffer message to the
      performance of XML.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para></para>

      <example>
        <title></title>

        <programlisting>package com.discursive.cjcook.proto;

import java.util.Date;

import com.discursive.cjcook.proto.Checkin.PositionData;
import com.google.protobuf.InvalidProtocolBufferException;

public class CheckinTiming {

  public static void main(String[] args) throws Exception {

    int size = 3000000;

    PositionData[] pArray = new PositionData[size];

    long preCreate = (new Date()).getTime();
    for( int i = 0; i &lt; size; i++ ) {
      PositionData pData = PositionData.newBuilder()
        .setVehicleId(1)
        .setTimestamp( (new Date()).getTime() )
        .setAltitude( 123.0f )
        .setLatitude( 1.0f )
        .setLongitude( 1.0f )
        .setSpeed( 120 )
        .build();
      pArray[i] = pData;
    }
    long postCreate = (new Date()).getTime();
    float createTime = 
      ((float) (postCreate - preCreate) / 
          (float) size ) * 1000 * 1000;

    System.out.printf( "Create One PositionData %.0f ns\n", createTime);
  
    byte[][] encodedArray = new byte[size][];
    long preEncode = (new Date()).getTime();
    for( int i = 0; i &lt; size; i++ ) {
      byte[] positionBArray = pArray[i].toByteArray();
      encodedArray[i] = positionBArray;

    }
    long postEncode = (new Date()).getTime();
    float encodeTime = 
      ((float) (postEncode - preEncode) / 
          (float) size ) * 1000 * 1000;
    System.out.printf( "Encode One PositionData to byte[] %.0f ns\n", 
                       encodeTime);

    PositionData[] decodedArray = new PositionData[size];
    long preDecode = (new Date()).getTime();
    for( int i = 0; i &lt; size; i++) {
      PositionData pData = PositionData.parseFrom( encodedArray[i] );
      decodedArray[i] = pData;
    }
    long postDecode = (new Date()).getTime();
    float decodeTime = 
      ((float) (postDecode - preDecode) / 
         (float) size ) * 1000 * 1000;
    System.out.printf( "Decode One PositionData from byte[] %.0f ns\n", 
                       decodeTime);
  }
}
</programlisting>
      </example>

      <para>Running this simple test program generates the following
      output:</para>

      <screen>Create One PositionData 488 ns
Encode One PositionData to byte[] 595 ns
Decode One PositionData from byte[] 970 ns</screen>

      <para>These numbers are going to vary on different platforms, but this
      is the general ballpark for Protocol Buffer encoding and decoding
      operations. Creating a Protocol Buffer message will take approximately
      500 nanoseconds, encoding it to a byte array will take 500 ns, and
      parsing the byte array will take about a microsecond.</para>
    </sect2>
  </sect1>
</chapter>
