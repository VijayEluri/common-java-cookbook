<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://mars.discursive.com/docbook/xml/4.5/docbookx.dtd">
<chapter id="http-webdav" label="11">
  <title>HTTP and WebDAV</title>

  <sect1 id="http-webdav-sect-intro">
    <title>Introduction</title>

    <para>The <indexterm id="http-webdav-ITERM-3195" significance="normal">
        <primary>Hypertext Transfer Protocol</primary>

        <see>HTTP</see>
      </indexterm>Hypertext Transfer <indexterm id="http-webdav-ITERM-3196"
        significance="normal">
        <primary>HTTP (Hypertext Transfer Protocol)</primary>
      </indexterm>Protocol (HTTP) is ubiquitous; this protocol is at the core
    of important technologies such as the <indexterm
        id="http-webdav-ITERM-3197" significance="normal">
        <primary>World Wide Web (WWW)</primary>
      </indexterm>World Wide Web (WWW), the <indexterm
        id="http-webdav-ITERM-3198" significance="normal">
        <primary>Simple Object Access Protocol</primary>

        <see>SOAP</see>
      </indexterm>Simple Object Access Protocol (SOAP), <indexterm
        id="http-webdav-ITERM-3199" significance="normal">
        <primary>SOAP (Simple Object Access Protocol)</primary>
      </indexterm>XML databases, content management systems, WebDAV, and, most
    importantly, iTunes. Much of the world's business is accomplished over
    HTTP in some form or another, and if this protocol were to suddenly
    vanish, a sizable portion of the world economy would vanish with it. Given
    this ubiquity, it is likely that you've had occasion to write a Java
    program that needed to fetch a web page or interact with a servlet or CGI
    script. While the J2SE contains some rudimentary tools to communicate via
    HTTP, the feature set of <literal moreinfo="none">URLConnection</literal>
    is somewhat limited. This chapter introduces Apache HttpClient, a set of
    utilities that simplifies the task of retrieving and sending information
    over HTTP.</para>

    <para>Apache HttpClient grew up in the Jakarta Commons, and until April
    2004 it was a Commons project. It subsequently graduated to a full Jakarta
    project, and as Jakarta was dismantled, it became an Apache top-level
    project. This chapter refers to HttpClient as Apache HttpClient, but you
    should be aware that most of the documentation and support still refer to
    the project as Commons HttpClient.</para>
  </sect1>

  <sect1 id="http-webdav-sect-obtaining-httpclient" label="11.1" role="Recipe">
    <title>Obtaining HttpClient</title>

    <sect2>
      <title>Problem</title>

      <para>You need to use <indexterm id="http-webdav-ITERM-3201"
          significance="normal">
          <primary>HTTP (Hypertext Transfer Protocol)</primary>

          <seealso> HttpClient</seealso>
        </indexterm>Apache HttpClient<indexterm id="http-webdav-ITERM-3202"
          significance="normal">
          <primary> HttpClient</primary>

          <secondary>downloading</secondary>
        </indexterm> <indexterm id="http-webdav-ITERM-3203"
          significance="normal">
          <primary>downloading</primary>

          <secondary> HttpClient</secondary>
        </indexterm> <indexterm id="http-webdav-ITERM-3204"
          significance="normal">
          <primary>clients</primary>

          <secondary> HttpClient</secondary>

          <tertiary>downloading</tertiary>
        </indexterm> to write a program to interact with a server over
      HTTP.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>To use Commons HttpClient 3.1 in a Maven 2 project, add the
      following dependency to your project's
      <filename>pom.xml</filename>:</para>

      <example id="http-webdav-ex-add-depend-httpclient">
        <title>Adding a Dependency on Commons HttpClient</title>

        <programlisting>    &lt;dependency&gt;
      &lt;groupId&gt;commons-httpclient&lt;/groupId&gt;
      &lt;artifactId&gt;commons-httpclient&lt;/artifactId&gt;
      &lt;version&gt;3.1&lt;/version&gt;
    &lt;/dependency&gt; </programlisting>
      </example>

      <para>If you are not sure what this means, I'd suggest reading <ulink
      url="http://www.sonatype.com/books/maven-book">Maven: The Definitive
      Guide</ulink>. When you depend on a library in Maven 2, all you need to
      do is add the dependency <varname>groupId</varname>,
      <varname>artifactId</varname>, and <varname>version</varname> to your
      project's dependencies. Once you do this, Maven 2 will download the
      dependency and make it available on your project's classpath.</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Apache HttpClient is a client library for the HTTP protocol.
      HttpClient is very feature-rich, supporting all HTTP methods defined in
      RFC 2616 (Hypertext Transfer Protocol, HTTP/1.1). Apache HttpClient
      supports GET, POST, PUT, OPTIONS, HEAD, and DELETE using the command
      pattern; <literal moreinfo="none">HttpMethod</literal> objects are
      instantiated and executed by an <literal
      moreinfo="none">HttpClient</literal> object that manages server
      interaction and state across multiple requests. HttpClient has support
      for various authentication mechanisms, including Basic, Digest, and NTLM
      authentication. HttpClient supports both HTTP and HTTPS, and the library
      can manage the complexity involved in using both schemes with an HTTP
      proxy. HttpClient can manage the state of a session, automatically
      keeping track of cookies across multiple requests.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>For more information about the HttpClient 3.1 project, see the
      project page (<ulink
      url="http://hc.apache.org/httpclient-3.x/">http://hc.apache.org/httpclient-3.x/</ulink>).</para>
    </sect2>
  </sect1>

  <sect1 id="http-webdav-sect-get" label="11.3" role="Recipe">
    <title>Performing an HTTP GET</title>

    <sect2>
      <title>Problem</title>

      <para>You need to retrieve information <indexterm
          id="http-webdav-ITERM-3210" significance="normal">
          <primary> HttpClient</primary>

          <secondary>GET method</secondary>
        </indexterm> <indexterm id="http-webdav-ITERM-3211"
          significance="normal">
          <primary>clients</primary>

          <secondary> HttpClient</secondary>

          <tertiary>GET method</tertiary>
        </indexterm> <indexterm id="http-webdav-ITERM-3212"
          significance="normal">
          <primary>GET method</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3213"
          significance="normal">
          <primary>methods</primary>

          <secondary>GET</secondary>
        </indexterm>with the HTTP GET method.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Create an instance of <literal
      moreinfo="none">HttpClient</literal> and use it to execute a <literal
      moreinfo="none">GetMethod</literal> <indexterm
          id="http-webdav-ITERM-3214" significance="normal">
          <primary>objects</primary>

          <secondary>GetMethod</secondary>
        </indexterm> <indexterm id="http-webdav-ITERM-3215"
          significance="normal">
          <primary>instances</primary>

          <secondary>HttpClient</secondary>
        </indexterm>object. Once the method has been executed, the response
      body can be accessed as an <literal
      moreinfo="none">InputStream</literal>, <literal
      moreinfo="none">byte[]</literal>, or <literal
      moreinfo="none">String</literal>. The following example gets the
      contents of <ulink
      url="http://www.discursive.com/jccook/">http://www.discursive.com/jccook/</ulink>
      and retrieves the response body as a string:</para>

      <programlisting format="linespecific" id="I_11_tt434">
               <userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpClient;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpException;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpMethod;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.methods.GetMethod;

HttpClient client = <userinput moreinfo="none">new</userinput> HttpClient( );
String url = "http://www.discursive.com/jccook/";
HttpMethod method = <userinput moreinfo="none">new</userinput> GetMethod( url );
    
<userinput moreinfo="none">try</userinput> {
    client.executeMethod( method );

    if( method.getStatusCode( ) == HttpStatus.SC_OK ) {
        String response = method.getResponseBodyAsString( );
        System.out.println( response );
    }
} <userinput moreinfo="none">catch</userinput>( HttpException he ) {
    System.out.println( "HTTP Problem: " + he.getMessage( ) );
} <userinput moreinfo="none">catch</userinput>( IOException ioe ) {
    System.out.println( "IO Exeception: " + ioe.getMessage( ) );
} <userinput moreinfo="none">finally</userinput> {
    method.releaseConnection( );
    method.recycle( );
}</programlisting>

      <para>This code retrieves the content of <ulink
      url="http://www.discursive.com/jccook">http://www.discursive.com/jccook</ulink>
      using the HTTP GET method. If the response code is <literal
      moreinfo="none">HttpStatus.SC_OK</literal> or <literal
      moreinfo="none">200</literal>, the response is printed to the
      console:</para>

      <programlisting format="linespecific" id="I_11_tt435">&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;JCCook Example&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;h1&gt;Hello World!&lt;/h1&gt;
 &lt;/body&gt;
&lt;/html&gt;</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Note the exception handling involved in this example. Performing a
      simple HTTP GET called for two catch blocks: <literal
      moreinfo="none">HttpException</literal> and <literal
      moreinfo="none">IOException</literal>. An <literal
      moreinfo="none">HttpException</literal> is thrown if there is a problem
      relating to the HTTP protocol, and an <literal
      moreinfo="none">IOException</literal> is thrown if there is a problem
      with the network. Examples in this chapter omit the rigorous exception
      handling from the previous example; you can assume that every call to
      <literal moreinfo="none">execute()</literal> is surrounded by the
      appropriate <literal moreinfo="none">try</literal>/<literal
      moreinfo="none">catch</literal> block.</para>

      <para><literal moreinfo="none">GetMethod</literal> is an implementation
      of the <literal moreinfo="none">HttpMethod</literal> interface, which is
      executed by <literal moreinfo="none">HttpClient</literal>. The lifecycle
      of any <literal moreinfo="none">HttpMethod</literal> implementation is
      straightforward; an <literal moreinfo="none">HttpMethod</literal> is
      created, executed by an instance of <literal
      moreinfo="none">HttpClient</literal>, and, once the response has been
      examined, the connection is released and the method is recycled. When an
      <literal moreinfo="none">HttpMethod</literal> object is recycled by a
      call to <literal moreinfo="none">recycle( )</literal>, it is a signal to
      the system that this specific <literal
      moreinfo="none">HttpMethod</literal> instance can be used again.
      <literal moreinfo="none">releaseConnection( )</literal> instructs
      <literal moreinfo="none">HttpClient</literal> to release the connection
      that is associated with an <literal moreinfo="none">HttpMethod</literal>
      instance. No matter what happens during the execution of a method, the
      <literal moreinfo="none">releaseConnection( )</literal> must be called
      to free network resources.</para>

      <para>Once a method has been executed, you can get the response status
      code from <literal moreinfo="none">method.getStatusCode( )</literal>.
      This method returns an <literal moreinfo="none">int</literal>, which
      will correspond to one of the <literal moreinfo="none">public static
      final</literal> variables on <literal
      moreinfo="none">HttpStatus</literal>. Some of the more common status
      codes on <literal moreinfo="none">HttpStatus</literal> are <literal
      moreinfo="none">SC_OK</literal> (200), <literal
      moreinfo="none">SC_NOT_FOUND</literal> (404), <literal
      moreinfo="none">SC_INTERNAL_SERVER_ERROR</literal> (500), <literal
      moreinfo="none">SC_MOVED_TEMPORARILY</literal> (302), and <literal
      moreinfo="none">SC_UNAUTHORIZED</literal> (401). For a full list of HTTP
      status codes, see the Javadoc for <literal
      moreinfo="none">HttpStatus</literal>. When a server sends back a bad
      HTTP status, it is sometimes accompanied by a short message. This
      message can be read by calling <literal
      moreinfo="none">method.getStatusText( )</literal>.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>For a formal definition of the HTTP GET method, see Section 9.3 of
      RFC 2616 at <ulink
      url="http://www.zvon.org/tmRFC/RFC2616/Output/index.html">http://www.zvon.org/tmRFC/RFC2616/Output/index.html</ulink>.</para>

      <para>For a full list of HTTP status codes, see the <literal
      moreinfo="none">HttpStatus</literal> Javadoc at <ulink
      url="http://hc.apache.org/httpclient-3.x/apidocs/index.html">http://hc.apache.org/httpclient-3.x/apidocs/index.html</ulink>.</para>
    </sect2>
  </sect1>

  <sect1 id="http-webdav-sect-get-param" label="11.4" role="Recipe">
    <title>Sending Parameters in a Query String</title>

    <sect2>
      <title>Problem</title>

      <para>You need to send query<indexterm class="startofrange"
          id="http-webdav-ITERM-3216" significance="normal">
          <primary> HttpClient</primary>

          <secondary>URLs, sending query parameters</secondary>
        </indexterm> <indexterm class="startofrange"
          id="http-webdav-ITERM-3217" significance="normal">
          <primary>URLs (uniform resource locators)</primary>

          <secondary> HttpClient</secondary>
        </indexterm> <indexterm class="startofrange"
          id="http-webdav-ITERM-3218" significance="normal">
          <primary>clients</primary>

          <secondary> HttpClient</secondary>

          <tertiary>sending query parameters</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="http-webdav-ITERM-3219" significance="normal">
          <primary>parameters</primary>

          <secondary>queries, sending</secondary>
        </indexterm> <indexterm class="startofrange"
          id="http-webdav-ITERM-3220" significance="normal">
          <primary>sending</primary>

          <secondary>query parameters</secondary>
        </indexterm> parameters in a URL.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Set the query string using the <literal
      moreinfo="none">setQueryString( )</literal> method on an instance of
      <literal moreinfo="none">HttpMethod</literal>. Use <literal
      moreinfo="none">URIUtil</literal> to encode any text included in a URL.
      The following example puts two parameters on the query string:</para>

      <programlisting format="linespecific" id="I_11_tt436">
               <userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpClient;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpException;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpMethod;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.NameValuePair;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.methods.GetMethod;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.util.URIUtil;

HttpClient client = <userinput moreinfo="none">new</userinput> HttpClient( );

String url = "http://www.discursive.com/cgi-bin/jccook/param_list.cgi";

HttpMethod method = <userinput moreinfo="none">new</userinput> GetMethod( url );

// Set the Query String with setQueryString( )
<userinput moreinfo="none">method.setQueryString(URIUtil.encodeQuery("test1=O Reilly&amp;blah=Whoop"));</userinput>
System.out.println( "With Query String: " + method.getURI( ) );

client.executeMethod( method );

System.out.println( "Response:\n " + method.getResponseBodyAsString( ) );
method.releaseConnection( );</programlisting>

      <para>The <filename moreinfo="none">param_list.cgi</filename> CGI script
      echoes all parameters received, and from the following output, you can
      see how <literal moreinfo="none">URIUtil</literal> encodes the first
      parameter:</para>

      <programlisting format="linespecific" id="I_11_tt437">With Query String: http://www.discursive.com/cgi-bin/jccook/param_list.
cgi?test1=O%20Reilly&amp;blah=Whoop
Response:
 These are the parameters I received:

test1:
  O Reilly
blah:
  Whoop</programlisting>

      <tip id="http-webdav-NOTE-71" role="ora">
        <para>The question mark is understood, and you do not need to supply a
        leading question mark to the <literal moreinfo="none">setQueryString(
        )</literal> method of <literal moreinfo="none">HttpMethod</literal>,
        as it will be automatically added when the method is executed by an
        instance of <literal moreinfo="none">HttpClient</literal>.</para>
      </tip>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>In the previous example, <literal
      moreinfo="none">method.setQueryString()</literal> <indexterm
          id="http-webdav-ITERM-3221" significance="normal">
          <primary>method.setQueryString( ) method</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3222"
          significance="normal">
          <primary>methods</primary>

          <secondary>method.setQueryString( )</secondary>
        </indexterm> is used to set the entire query string at once, but there
      is another alternative: setting the query string with an array of
      <literal moreinfo="none">NameValuePair</literal> objects. When a
      <literal moreinfo="none">NameValuePair[]</literal> <indexterm
          id="http-webdav-ITERM-3223" significance="normal">
          <primary>NameValuePair</primary>
        </indexterm> is passed to <literal
      moreinfo="none">method.setQueryString( )</literal>, the <literal
      moreinfo="none">HttpMethod</literal> then takes each pair and creates a
      series of parameters delimited by an ampersand. The approach encourages
      cleaner code because you are not concatenating strings to pass multiple
      parameters. The following example sets the same parameters used in the
      previous example, using <literal moreinfo="none">NameValuePair</literal>
      objects:</para>

      <programlisting format="linespecific" id="I_11_tt438">// Set query string with name value pair objects
HttpMethod method = <userinput moreinfo="none">new</userinput> GetMethod( url );
NameValuePair pair = 
<userinput moreinfo="none">    new</userinput> NameValuePair( "test1", URIUtil.encodeQuery( "O Reilly" ) );
NameValuePair pair2 = 
    <userinput moreinfo="none">new</userinput> NameValuePair( "blah", URIUtil.encodeQuery( "Whoop" ) );
NameValuePair[] pairs = <userinput moreinfo="none">new</userinput> NameValuePair[] { pair, pair2 };
method.setQueryString( pairs );
System.out.println( "With NameValuePairs: " + method.getURI( ) );
client.executeMethod( method );
System.out.println( "Response:\n " + method.getResponseBodyAsString( ) );
method.releaseConnection( );</programlisting>

      <para>According to RFC 1738 (Uniform Resource Locators (URL)
      specification) URLs can only contain alphanumeric characters, <literal
      moreinfo="none">[0-9a-zA-Z]</literal>, and a few other special
      characters. If you need to send a parameter with an unacceptable
      character in a URL, you will need to encode your string according to the
      standard defined in RFC 1738. <literal moreinfo="none">URIUtil</literal>
      exposes a method <literal moreinfo="none">encodeQuery( )</literal> that
      can be used to encode the value "O Reilly" in the previous example. The
      following code demonstrates the use of <literal
      moreinfo="none">URIUtil</literal> to encode strings for inclusion in a
      URL:</para>

      <programlisting format="linespecific" id="I_11_tt439">String encoded1 = URIUtil.encodeQuery( "&lt;test&gt;=O'Connell" );
String encoded2 = URIUtil.encodeQuery( "one:two=thr ee#" );

String decoded = URIUtil.decode( "Hello%20World%3F" );

System.out.println( "Encoded: " + encoded1 );
System.out.println( "Encoded: " + encoded2 );
System.out.println( "Decoded: " + decoded );</programlisting>

      <para>This simple example encodes two strings and decodes an encoded
      string using <literal moreinfo="none">URIUtil</literal>. The output
      shows the result of each transformation:</para>

      <programlisting format="linespecific" id="I_11_tt440">Encoded: %3ctest%e3=O'Connell
Encoded: one%3atwo=thr%20ee#23
Decoded: Hello World?</programlisting>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>In this example, <literal moreinfo="none">URLUtil</literal> was
      used to encode content passed in on the query string. This HttpClient
      team has recently moved some of the URL encoding and decoding logic to
      the Commons Codec project as a class named <literal
      moreinfo="none">URLCodec</literal>. For more information about <literal
      moreinfo="none">URLCodec</literal>, see the Commons Codec project page
      (<ulink
      url="http://jakarta.apache.org/codec">http://commons.apache.org/codec</ulink>).</para>

      <para>RFC 1738 discusses the legal characters <indexterm
      class="endofrange" id="http-webdav-ITERM-3224" significance="normal"
      startref="http-webdav-ITERM-3216"></indexterm> <indexterm
      class="endofrange" id="http-webdav-ITERM-3225" significance="normal"
      startref="http-webdav-ITERM-3217"></indexterm> <indexterm
      class="endofrange" id="http-webdav-ITERM-3226" significance="normal"
      startref="http-webdav-ITERM-3218"></indexterm> <indexterm
      class="endofrange" id="http-webdav-ITERM-3227" significance="normal"
      startref="http-webdav-ITERM-3219"></indexterm> <indexterm
      class="endofrange" id="http-webdav-ITERM-3228" significance="normal"
      startref="http-webdav-ITERM-3220"></indexterm>for a URL and defines a
      process for encoding other characters. RFC 1738 can be found at <ulink
      url="http://www.zvon.org/tmRFC/RFC2616/Output/index.html">http://www.zvon.org/tmRFC/RFC2616/Output/index.html</ulink>.</para>
    </sect2>
  </sect1>

  <sect1 id="http-webdav-sect-cond-get" label="11.5" role="Recipe">
    <title>Retrieving Content with a Conditional GET</title>

    <sect2>
      <title>Problem</title>

      <para>You need to retrieve <indexterm class="startofrange"
          id="http-webdav-ITERM-3229" significance="normal">
          <primary>HttpClient</primary>

          <secondary>GET method</secondary>
        </indexterm> <indexterm class="startofrange"
          id="http-webdav-ITERM-3230" significance="normal">
          <primary>clients</primary>

          <secondary>HttpClient</secondary>

          <tertiary>GET method</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="http-webdav-ITERM-3231" significance="normal">
          <primary>GET method</primary>
        </indexterm> <indexterm class="startofrange"
          id="http-webdav-ITERM-3232" significance="normal">
          <primary>methods</primary>

          <secondary>GET</secondary>
        </indexterm>the same content <indexterm id="http-webdav-ITERM-3233"
          significance="normal">
          <primary>retrieving content (conditional GET method)</primary>
        </indexterm>more than once, and you would like to have the server only
      send the content if it has changed since the last request.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Create a <literal moreinfo="none">GetMethod</literal> and set the
      <filename moreinfo="none">If-None-Match</filename> and <filename
      moreinfo="none">If-Modified-Since</filename> headers; these two headers
      will instruct the server to refrain from sending content if the content
      has not been altered since the last request. <link
      linkend="http-webdav-ex-1">Example 11-1</link> makes three separate
      requests for the same URL (<ulink
      url="http://www.apache.org">http://www.apache.org</ulink>), and, because
      the content remains static, it is only sent in the response body of the
      first request.</para>

      <example id="http-webdav-ex-1" label="11-1">
        <title>Requesting information with a conditional GET</title>

        <programlisting format="linespecific">
                  <userinput moreinfo="none">import</userinput> java.io.IOException;

<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.Header;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HeaderElement;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpClient;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpException;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpMethod;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpStatus;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.methods.GetMethod;

<userinput moreinfo="none">public</userinput> 
                  <userinput moreinfo="none">class</userinput> ConditionalGetExample {

    <userinput moreinfo="none">public</userinput> 
                  <userinput moreinfo="none">static</userinput> 
                  <userinput moreinfo="none">void</userinput> main(String[] args) <userinput
            moreinfo="none">throws</userinput> HttpException, IOException {
        ConditionalGetExample example = <userinput moreinfo="none">new</userinput> ConditionalGetExample( );
        example.start( );
    }
    
    String entityTag = "";
    String lastModified = "";
    
    <userinput moreinfo="none">public</userinput> 
                  <userinput moreinfo="none">void</userinput> start( ) <userinput
            moreinfo="none">throws</userinput> HttpException, IOException {

        HttpClient client = <userinput moreinfo="none">new</userinput> HttpClient( );
        HttpMethod method = <userinput moreinfo="none">new</userinput> GetMethod("http://www.apache.org");

        <userinput moreinfo="none">for</userinput>( <userinput moreinfo="none">int</userinput> i = 0; i &lt; 3; i++ ) {
            setHeaders(method);
            client.executeMethod(method);
            processResults(method);
            method.releaseConnection( );
            method.recycle( );
        }
    }

    <userinput moreinfo="none">private</userinput> 
                  <userinput moreinfo="none">void</userinput> setHeaders(HttpMethod method) {
        method.setRequestHeader(<userinput moreinfo="none">new</userinput> Header("If-None-Match", entityTag ) );
        method.setRequestHeader(<userinput moreinfo="none">new</userinput> Header("If-Modified-Since", 
                               lastModified ) );
    }

    <userinput moreinfo="none">private</userinput> 
                  <userinput moreinfo="none">void</userinput> processResults(HttpMethod method) <userinput
            moreinfo="none">throws</userinput> HttpException {
        <userinput moreinfo="none">if</userinput>(method.getStatusCode( ) == HttpStatus.SC_NOT_MODIFIED ) {
            System.out.println( "Content not modified since last request" );
        } <userinput moreinfo="none">else</userinput> {
            entityTag = retrieveHeader( method, "ETag" );
            lastModified = retrieveHeader( method, "Last-Modified" );
            System.out.println( "Get Method retrieved content." );
            System.out.println( "Entity Tag: " + entityTag );
            System.out.println( "Last Modified: " + lastModified );
        } 
    }
    
    <userinput moreinfo="none">private</userinput> String retrieveHeader( HttpMethod method, String name ) 
<userinput moreinfo="none">        throws</userinput> HttpException {
        HeaderElement[] header = method.getResponseHeader("ETag").
                                 getElements( );
        String value = "";
        <userinput moreinfo="none">if</userinput>(header.length &gt; 0) {
         value = header[0].getName( );
        }
        <userinput moreinfo="none">return</userinput> value;
    }
}</programlisting>
      </example>

      <para><link linkend="http-webdav-ex-1">Example 11-1</link> requests the
      same page three times; the first request retrieves the content, and the
      second and third requests contain the headers for a conditional HTTP
      GET. Because the Apache homepage remains unchanged throughout this
      example, the content of <ulink
      url="http://www.apache.org">http://www.apache.org</ulink> is retrieved
      only once. This example uses the headers in the first response to
      populate the <filename moreinfo="none">If-None-Match</filename> and
      <filename moreinfo="none">If-Modified-Since</filename> headers for the
      second and third requests:</para>

      <programlisting format="linespecific" id="I_11_tt441">Request 1. Get Method retrieved content.
Entity Tag: "2da794a-2d0d-998ebc80"
Last Modified: Wed, 14 Apr 2004 05:53:38 GMT

Request 2. Content not modified since last request

Request 3. Content not modified since last request</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>This first request is similar to a regular HTTP GET, and if you
      examine the contents of the first request and response, you will see
      that the server's response contains two headers:</para>

      <programlisting format="linespecific" id="I_11_tt442">Last-Modified: Wed, 05 May 2004 02:51:59 GMT
ETag: "a06d2-76-829811c0"</programlisting>

      <para><link linkend="http-webdav-ex-1">Example 11-1</link> takes the
      values of these two response headers and stores them in the <literal
      moreinfo="none">entityTag</literal> and <literal
      moreinfo="none">lastModified</literal> variables. When the next request
      is made, the values of these two variables are used to populate the
      conditional headers <filename moreinfo="none">If-None-Match</filename>
      and <filename moreinfo="none">If-Modified-Since</filename> in the
      <literal moreinfo="none">setHeaders()</literal> method. These request
      headers are present in the second request for the same resource:</para>

      <programlisting format="linespecific" id="I_11_tt443">GET / HTTP/1.1
If-None-Match: "2da7807-31a8-e1eeb400"
If-Modified-Since: Tue, 11 May 2004 23:57:04 GMT
User-Agent: Jakarta Commons-HttpClient/3.0final
Host: www.apache.org</programlisting>

      <para>When the server receives these conditional headers, it will check
      to see if the resource has been modified. If the resource has been
      modified, the resource will have a different modified date and different
      entity tag value. If the resource has not been modified, the server will
      respond to <literal moreinfo="none">HttpClient</literal> with a <literal
      moreinfo="none">304 Not Modified</literal> response code:</para>

      <programlisting format="linespecific" id="I_11_tt444">HTTP/1.1 304 Not Modified
Date: Sat, 15 May 2004 16:59:23 GMT
Server: Apache/2.0.49-dev (Unix)
ETag: "2da7807-31a8-e1eeb400"
Expires: Sun, 16 May 2004 16:59:23 GMT
Cache-Control: max-age=86400</programlisting>

      <para>The <filename moreinfo="none">ETag</filename> <indexterm
          id="http-webdav-ITERM-3234" significance="normal">
          <primary>ETag headers</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3235"
          significance="normal">
          <primary>headers</primary>

          <secondary>ETag</secondary>
        </indexterm> <indexterm id="http-webdav-ITERM-3236"
          significance="normal">
          <primary>entity tags</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3237"
          significance="normal">
          <primary>tags</primary>

          <secondary>entity</secondary>
        </indexterm> header is known as an <filename moreinfo="none">entity
      tag</filename>, and it is similar to a hash code for a resource served
      by a particular web server. Different servers have different algorithms
      for creating an <filename moreinfo="none">ETag</filename> header; for
      example, the Apache HTTPD server has a configuration directive, which
      allows you to base an <filename moreinfo="none">ETag</filename> on a
      configurable set of file attributes, such as size, i-node number, and
      modified time. Consider an <filename moreinfo="none">ETag</filename> to
      be a unique identifier for a particular version of a resource; if this
      header changes, the corresponding resource has been altered.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>Entity tags (the <filename moreinfo="none">ETag</filename> header)
      are described in sections 3.11 and 14.19 of RFC 2616 (<ulink
      url="http://www.zvon.org/tmRFC/RFC2616/Output/index.html">http://www.zvon.org/tmRFC/RFC2616/Output/index.html</ulink>).
      The Apache HTTPD server can be configured to use different file
      attributes when creating an <filename moreinfo="none">ETag</filename>
      header. For more information about configuring the Apache HTTPD
      server<indexterm class="endofrange" id="http-webdav-ITERM-3238"
      significance="normal" startref="http-webdav-ITERM-3229"></indexterm>
      <indexterm class="endofrange" id="http-webdav-ITERM-3239"
      significance="normal" startref="http-webdav-ITERM-3230"></indexterm>
      <indexterm class="endofrange" id="http-webdav-ITERM-3240"
      significance="normal" startref="http-webdav-ITERM-3231"></indexterm>
      <indexterm class="endofrange" id="http-webdav-ITERM-3241"
      significance="normal" startref="http-webdav-ITERM-3232"></indexterm> via
      the <literal moreinfo="none">FileETag</literal> directive, see the
      documentation of Apache's core features (<ulink
      url="http://httpd.apache.org/docs-2.0/mod/core.html#fileetag">http://httpd.apache.org/docs-2.0/mod/core.html#fileetag</ulink>).</para>
    </sect2>
  </sect1>

  <sect1 id="http-webdav-sect-debug-http" label="11.6" role="Recipe">
    <title>Debugging HTTP Communications</title>

    <sect2>
      <title>Problem</title>

      <para>You need to see the low-level communications <indexterm
          class="startofrange" id="http-webdav-ITERM-3242"
          significance="normal">
          <primary>HttpClient</primary>

          <secondary>debugging</secondary>
        </indexterm> <indexterm class="startofrange"
          id="http-webdav-ITERM-3243" significance="normal">
          <primary>debugging</primary>

          <secondary>HttpClient</secondary>
        </indexterm> <indexterm class="startofrange"
          id="http-webdav-ITERM-3244" significance="normal">
          <primary>clients</primary>

          <secondary>HttpClient</secondary>

          <tertiary>debugging</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="http-webdav-ITERM-3245" significance="normal">
          <primary>servers</primary>

          <secondary>HTTP, debugging</secondary>
        </indexterm>between the client and the server.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Set four <literal moreinfo="none">System</literal> variables that
      control logging, and <literal moreinfo="none">HttpClient</literal>
      <indexterm id="http-webdav-ITERM-3246" significance="normal">
          <primary>logging</primary>

          <secondary>HttpClient</secondary>
        </indexterm>will produce debugging statements dealing with environment
      information, SSL configuration information, and the raw data sent to and
      received from the server. The following example sets the four <literal
      moreinfo="none">System</literal> properties that control <literal
      moreinfo="none">HttpClient</literal> debugging output:</para>

      <programlisting format="linespecific" id="I_11_tt445">
               <userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpClient;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpException;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpMethod;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.methods.GetMethod;

String logging = "org.apache.commons.logging";

// Configure Logging
System.setProperty(logging + ".Log", logging + ".impl.SimpleLog");
System.setProperty(logging + ".logging.simplelog.showdatetime", "true");
System.setProperty(logging + ".simplelog.log.httpclient.wire", "debug");        
System.setProperty(logging + ".simplelog.log.org.apache.commons.httpclient", 
                   "debug");
        
HttpClient client = <userinput moreinfo="none">new</userinput> HttpClient( );
String url = "http://www.discursive.com/jccook/";
HttpMethod method = <userinput moreinfo="none">new</userinput> GetMethod( url );
client.executeMethod( method );
String response = method.getResponseBodyAsString( );

System.out.println( response );
method.releaseConnection( );
method.recycle( );</programlisting>

      <para>This code executes a simple <literal
      moreinfo="none">GetMethod</literal> and produces the following debugging
      output, which contains environment information and a log of all data
      sent and received from the server:</para>

      <programlisting format="linespecific" id="I_11_tt446">HttpClient - -Java version: 1.4.2_04
HttpClient - -Java vendor: Sun Microsystems Inc.
HttpClient - -Java class path: 
HttpClient - -Operating system name: Windows XP
HttpClient - -Operating system architecture: x86
HttpClient - -Operating system version: 5.1
HttpClient - -SUN 1.42: SUN (DSA key/parameter generation; DSA signing; SHA-1, \
             MD5  digests; SecureRandom; X.509 certificates; JKS keystore; \
             PKIX CertPathValidator; PKIX CertPathBuilder; LDAP, Collection \
             CertStores)
HttpClient - -SunJSSE 1.42: Sun JSSE provider(implements RSA Signatures, \
             PKCS12, SunX509 key/trust factories, SSLv3, TLSv1)
HttpClient - -SunRsaSign 1.42: SUN's provider for RSA signatures
HttpClient - -SunJCE 1.42: SunJCE Provider (implements DES, Triple DES, \
             AES, Blowfish, PBE, Diffie-Hellman, HMAC-MD5, HMAC-SHA1)
HttpClient - -SunJGSS 1.0: Sun (Kerberos v5)
HttpConnection - -HttpConnection.setSoTimeout(0)
HttpMethodBase - -Execute loop try 1
wire - -&gt;&gt; "GET /jccook/ HTTP/1.1[\r][\n]"
HttpMethodBase - -Adding Host request header
wire - -&gt;&gt; "User-Agent: Jakarta Commons-HttpClient/3.0final[\r][\n]"
wire - -&gt;&gt; "Host: www.discursive.com[\r][\n]"
wire - -&gt;&gt; "[\r][\n]"
wire - -&lt;&lt; "HTTP/1.1 200 OK[\r][\n]"
wire - -&lt;&lt; "Date: Thu, 06 May 2004 02:49:43 GMT[\r][\n]"
wire - -&lt;&lt; "Server: Apache/2.0.48 (Fedora)[\r][\n]"
wire - -&lt;&lt; "Last-Modified: Wed, 05 May 2004 02:51:37 GMT[\r][\n]"
wire - -&lt;&lt; "ETag: "a06d1-68-81486040"[\r][\n]"
wire - -&lt;&lt; "Accept-Ranges: bytes[\r][\n]"
wire - -&lt;&lt; "Content-Length: 104[\r][\n]"
wire - -&lt;&lt; "Content-Type: text/html; charset=UTF-8[\r][\n]"
HttpMethodBase - -Buffering response body
wire - -&lt;&lt; "&lt;html&gt;[\n]"
wire - -&lt;&lt; " &lt;head&gt;[\n]"
wire - -&lt;&lt; "  &lt;title&gt;JCCook Example&lt;/title&gt;[\n]"
wire - -&lt;&lt; " &lt;/head&gt;[\n]"
wire - -&lt;&lt; " &lt;body&gt;[\n]"
wire - -&lt;&lt; "  &lt;h1&gt;Hello World!&lt;/h1&gt;[\n]"
wire - -&lt;&lt; " &lt;/body&gt;[\n]"
wire - -&lt;&lt; "&lt;/html&gt;"
HttpMethodBase - -Resorting to protocol version default close connection policy
HttpMethodBase - -Should NOT close connection, using HTTP/1.1.
&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;JCCook Example&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;h1&gt;Hello World!&lt;/h1&gt;
 &lt;/body&gt;
&lt;/html&gt;</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>The ability to see the communications between a browser and a
      server is a great diagnostic tool, and, throughout this chapter, the
      wire protocol logging properties have been used to provide some insight
      into the inner workings of <literal
      moreinfo="none">HttpClient</literal>. There were four <literal
      moreinfo="none">System</literal> properties set in the previous
      example:</para>

      <variablelist>
        <varlistentry>
          <term><literal
          moreinfo="none">org.apache.commons.logging.simplelog.log.httpclient.wire</literal></term>

          <listitem>
            <para>Setting this property to <literal
            moreinfo="none">debug</literal> causes an <literal
            moreinfo="none">HttpClient</literal> instance to print out all
            traffic sent to and received from a web server.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal
          moreinfo="none">org.apache.commons.logging.simplelog.log.org.apache.commons.httpclient</literal></term>

          <listitem>
            <para>Setting this property to <literal
            moreinfo="none">debug</literal> configures <literal
            moreinfo="none">HttpClient</literal> to print general debugging
            information. In the previous example, every line starting with
            <literal moreinfo="none">HttpClient</literal> or <literal
            moreinfo="none">HttpMethodBase</literal> is a debugging message
            configured by this setting.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal
          moreinfo="none">org.apache.commons.logging.Log</literal></term>

          <listitem>
            <para>Setting this property to <literal
            moreinfo="none">org.apache.commons.logging.impl.SimpleLog</literal>
            configures <literal moreinfo="none">HttpClient</literal> to log
            output to the console.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal
          moreinfo="none">org.apache.commons.logging.simplelog.showdatetime</literal></term>

          <listitem>
            <para>Setting this to <literal moreinfo="none">true</literal> will
            cause the <literal moreinfo="none">SimpleLog</literal> to
            <indexterm class="endofrange" id="http-webdav-ITERM-3247"
            significance="normal"
            startref="http-webdav-ITERM-3242"></indexterm> <indexterm
            class="endofrange" id="http-webdav-ITERM-3248"
            significance="normal"
            startref="http-webdav-ITERM-3243"></indexterm> <indexterm
            class="endofrange" id="http-webdav-ITERM-3249"
            significance="normal"
            startref="http-webdav-ITERM-3244"></indexterm> <indexterm
            class="endofrange" id="http-webdav-ITERM-3250"
            significance="normal"
            startref="http-webdav-ITERM-3245"></indexterm>print the date and
            time for every message.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>
  </sect1>

  <sect1 id="http-webdav-sect-http-post" label="11.7" role="Recipe">
    <title>Making an HTTP POST Request</title>

    <sect2>
      <title>Problem</title>

      <para>You need to supply parameters to a<indexterm class="startofrange"
          id="http-webdav-ITERM-3251" significance="normal">
          <primary>HttpClient</primary>

          <secondary>HTTP POST requests</secondary>
        </indexterm> <indexterm class="startofrange"
          id="http-webdav-ITERM-3252" significance="normal">
          <primary>HTTP POST requests</primary>
        </indexterm> <indexterm class="startofrange"
          id="http-webdav-ITERM-3253" significance="normal">
          <primary>clients</primary>

          <secondary>HTTP POST requests</secondary>
        </indexterm> <indexterm class="startofrange"
          id="http-webdav-ITERM-3254" significance="normal">
          <primary>parameters</primary>

          <secondary>HTTP POST requests</secondary>
        </indexterm> <indexterm class="startofrange"
          id="http-webdav-ITERM-3255" significance="normal">
          <primary>scripts</primary>

          <secondary>HTTP POST requests</secondary>
        </indexterm> <indexterm class="startofrange"
          id="http-webdav-ITERM-3256" significance="normal">
          <primary>servlets, HTTP POST requests</primary>
        </indexterm> script or servlet using HTTP POST.</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Create a <literal moreinfo="none">PostMethod</literal> and call
      <literal moreinfo="none">setParameter( )</literal> <indexterm
          id="http-webdav-ITERM-3257" significance="normal">
          <primary>setParameter( ) method</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3258"
          significance="normal">
          <primary>methods</primary>

          <secondary>setParameter( )</secondary>
        </indexterm> or <literal moreinfo="none">addParameter()</literal>
      <indexterm id="http-webdav-ITERM-3259" significance="normal">
          <primary>addParameter( ) method</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3260"
          significance="normal">
          <primary>methods</primary>

          <secondary>addParameter( )</secondary>
        </indexterm> before you execute the method. The <literal
      moreinfo="none">PostMethod</literal> will send a request with a
      <filename moreinfo="none">Content-Type</filename> header of <filename
      moreinfo="none">application/x-www-form-urlencoded</filename>, and the
      parameters will be sent in the request body. The following example
      demonstrates the use of <literal moreinfo="none">PostMethod</literal>
      <indexterm id="http-webdav-ITERM-3261" significance="normal">
          <primary>PostMethod</primary>
        </indexterm> to<indexterm id="http-webdav-ITERM-3262"
          significance="normal">
          <primary>sending</primary>

          <secondary>parameters</secondary>
        </indexterm> send parameters:</para>

      <programlisting format="linespecific" id="I_11_tt447">
               <userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpClient;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpException;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.NameValuePair;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.methods.PostMethod;

HttpClient client = <userinput moreinfo="none">new</userinput> HttpClient( );
        
// Create POST method
String url = "http://www.discursive.com/cgi-bin/jccook/param_list.cgi";
PostMethod method = <userinput moreinfo="none">new</userinput> PostMethod( url );

<emphasis role="bold">// Set parameters on POST</emphasis>    
               <emphasis role="bold">method.setParameter( "test1", "Hello World" );</emphasis>
               <emphasis role="bold">method.addParameter( "test2", "This is a Form Submission" );</emphasis>
               <emphasis role="bold">method.addParameter( "Blah", "Whoop" );</emphasis>
               <emphasis role="bold">method.addParameter( new NameValuePair( "Blah", "Whoop2" ) );</emphasis>

// Execute and print response
client.executeMethod( method );
String response = method.getResponseBodyAsString( );
System.out.println( response );

method.releaseConnection( );</programlisting>

      <para>The <filename moreinfo="none">param_list.cgi</filename> CGI script
      echoes all parameters received, and from the following output, you can
      see that three parameters were supplied to this script:</para>

      <programlisting format="linespecific" id="I_11_tt448">These are the parameters I received:

test1:
  Hello World
test2:
  This is a Form Submission
Blah:
  Whoop
  Whoop2</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>The previous example sent the parameters in the request body. The
      request created by the previous example is shown below:</para>

      <programlisting format="linespecific" id="I_11_tt449">POST /cgi-bin/jccook/param_list.cgi HTTP/1.1[\r][\n]
User-Agent: Jakarta Commons-HttpClient/3.0final[\r][\n]
Host: www.discursive.com[\r][\n]
Content-Length: 72[\r][\n]
Content-Type: application/x-www-form-urlencoded[\r][\n]
[\r][\n]
test1=Hello+World&amp;test2=This+is+a+Form+Submission&amp;Blah=Whoop&amp;Blah=Whoop2</programlisting>

      <tip id="http-webdav-NOTE-72" role="ora">
        <para>This output was produced by turning on wire debugging for
        <literal moreinfo="none">HttpClient</literal>, as described in Recipe
        11.6.</para>
      </tip>

      <para>The first line specifies the HTTP method, the request path, and
      the protocol. The second line identifies this client as HttpClient
      Version 3.0. The third line specifies the request host and is used by
      servers serving many different virtual hosts using one IP address. The
      fourth line states that the request body is exactly 72 bytes, and the
      <filename moreinfo="none">Content-Type</filename> header defines the
      request body as being a series of URL-encoded parameters. The parameters
      are passed in one line as <filename
      moreinfo="none">name1=value1&amp;name2=value&amp;</filename>,
      etc.</para>

      <para>There are a few ways to specify parameters on a <literal
      moreinfo="none">PostMethod</literal>. The most straightforward is to
      call <literal moreinfo="none">setParameter( )</literal> with two
      strings: the parameter name and parameter value. <literal
      moreinfo="none">setParameter( )</literal> will replace any existing
      parameter with the same name. If a parameter with the same name is
      already present in a <literal moreinfo="none">PostMethod</literal>,
      <literal moreinfo="none">addParameter( )</literal> will add another
      value to an existing parameter; <literal moreinfo="none">addParameter(
      )</literal> also accepts two strings: the name and value. Alternatively,
      both methods can be called with a <literal
      moreinfo="none">NameValuePair</literal> object that encapsulates the
      name and value of a parameter. The previous example sent two values for
      the parameter <filename moreinfo="none">Blah</filename>, which were both
      added using <literal moreinfo="none">addParameter( )</literal>. The
      first was added with two string parameters, and the second was added
      using a <literal moreinfo="none">NameValuePair</literal> object.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>The POST method is defined in detail in Section 9.5 of RFC 2616
      (<ulink
      url="http://www.zvon.org/tmRFC/RFC2616/Output/index.html">http://www.zvon.org/tmRFC/RFC2616/Output/index.html</ulink>).</para>
    </sect2>
  </sect1>

  <sect1 id="http-webdav-sect-post-file" label="11.8" role="Recipe">
    <title>Sending POST Data from a File</title>

    <sect2>
      <title>Problem</title>

      <para>You need to send the data from<indexterm
          id="http-webdav-ITERM-3263" significance="normal">
          <primary>sending</primary>

          <secondary>HTTP POST request files</secondary>
        </indexterm> <indexterm id="http-webdav-ITERM-3264"
          significance="normal">
          <primary>files</primary>

          <secondary>HTTP POST requests</secondary>
        </indexterm> a file in an HTTP POST request.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Create a <literal moreinfo="none">PostMethod</literal>, create a
      <literal moreinfo="none">File</literal> object, and call <literal
      moreinfo="none">setRequestBody( )</literal> <indexterm
          id="http-webdav-ITERM-3265" significance="normal">
          <primary>setRequestBody( ) method</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3266"
          significance="normal">
          <primary>methods</primary>

          <secondary>setRequestBody( )</secondary>
        </indexterm> and <literal
      moreinfo="none">setRequestContentLength()</literal> <indexterm
          id="http-webdav-ITERM-3267" significance="normal">
          <primary>setRequestContentLength( ) method</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3268"
          significance="normal">
          <primary>methods</primary>

          <secondary>setRequestContentLength( )</secondary>
        </indexterm> on the method before it is executed. The <literal
      moreinfo="none">PostMethod</literal> will send a request with a
      <filename moreinfo="none">Content-Length</filename> header, which
      reflects the size of the file sent in the request body. The following
      example demonstrates the use of <literal
      moreinfo="none">PostMethod</literal> to send data from a file in a
      request body:</para>

      <programlisting format="linespecific" id="I_11_tt450">
               <userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpClient;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpException;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.methods.PostMethod;

HttpClient client = <userinput moreinfo="none">new</userinput> HttpClient( );
        
// Create POST method
String weblintURL = "http://ats.nist.gov/cgi-bin/cgi.tcl/echo.cgi";
PostMethod method = <userinput moreinfo="none">new</userinput> PostMethod( weblintURL );

File file = <userinput moreinfo="none">new</userinput> File( "project.xml" );
<emphasis role="bold">method.setRequestBody( new FileInputStream( file ) );</emphasis>
               <emphasis role="bold">method.setRequestContentLength( (int)file.length( ) );</emphasis>

// Execute and print response
client.executeMethod( method );
String response = method.getResponseBodyAsString( );
System.out.println( response );

method.releaseConnection( );</programlisting>

      <para>The previous example hits a CGI script, which echoes the contents
      of the request body. When this example is executed, the response body is
      printed with the contents of the file that was uploaded in an HTTP POST
      request.</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>This recipe sets the request body of an HTTP POST directly by
      passing a <literal moreinfo="none">File</literal> object to <literal
      moreinfo="none">method.setRequestBody()</literal>. In addition to
      accepting a <literal moreinfo="none">File</literal> object, <literal
      moreinfo="none">setRequestBody( )</literal> can accept an <literal
      moreinfo="none">InputStream</literal> or a <literal
      moreinfo="none">String</literal>. Any time a request body is populated,
      the <filename moreinfo="none">Content-Length</filename> header must be
      set to reflect the size of the request body by calling <literal
      moreinfo="none">method.setRequestContentLength( )</literal>. The
      previous recipe sent parameters in an HTTP POST request body by calling
      <literal moreinfo="none">setParameter( )</literal> and <literal
      moreinfo="none">addParameter()</literal>, and the <filename
      moreinfo="none">Content-Length</filename> and <filename
      moreinfo="none">Content-Type</filename> headers are automatically
      populated when the method is executed. In this example, the <filename
      moreinfo="none">Content-Type</filename> header is not sent with the
      request as the content can be any arbitrary textual or binary
      data.</para>
    </sect2>
  </sect1>

  <sect1 id="http-webdav-sect-upload-multipart-post" label="11.9"
         role="Recipe">
    <title>Uploading Files with a Multipart POST</title>

    <sect2>
      <title>Problem</title>

      <para>You need to upload a file or a<indexterm
          id="http-webdav-ITERM-3269" significance="normal">
          <primary>uploading files</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3270"
          significance="normal">
          <primary>files</primary>

          <secondary>uploading</secondary>
        </indexterm> set of files with an HTTP multipart POST.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Create a <literal moreinfo="none">MultipartPostMethod</literal>
      and add <literal moreinfo="none">File</literal> objects as parameters
      using <literal moreinfo="none">addParameter( )</literal> and <literal
      moreinfo="none">addPart( )</literal>. The <literal
      moreinfo="none">MultipartPostMethod</literal> <indexterm
          id="http-webdav-ITERM-3271" significance="normal">
          <primary>MultipartPostMethod</primary>
        </indexterm> creates a request with a <filename
      moreinfo="none">Content-Type</filename> header of <filename
      moreinfo="none">multipart/form-data</filename>, and each part is
      separated by a boundary. The following example sends two files in an
      HTTP multipart POST:</para>

      <programlisting format="linespecific" id="I_11_tt451">
               <userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpClient;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpException;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.methods.MultipartPostMethod;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.methods.multipart.FilePart;

HttpClient client = <userinput moreinfo="none">new</userinput> HttpClient( );
        
// Create POST method
String weblintURL = "http://ats.nist.gov/cgi-bin/cgi.tcl/echo.cgi";
MultipartPostMethod method = 
<userinput moreinfo="none">    new</userinput> MultipartPostMethod( weblintURL );

<userinput moreinfo="none">File file = new File( "data", "test.txt" );</userinput>
               <userinput moreinfo="none">File file2 = new File( "data", "sample.txt" );</userinput>
               <userinput moreinfo="none">method.addParameter("test.txt", file );</userinput>
               <userinput moreinfo="none">method.addPart( new FilePart( "sample.txt", file2, "text/plain", 
"ISO-8859-1" ) ); </userinput>

// Execute and print response
client.executeMethod( method );
String response = method.getResponseBodyAsString( );
System.out.println( response );

method.releaseConnection( );</programlisting>

      <para>Two <literal moreinfo="none">File</literal> objects are added to
      the <literal moreinfo="none">MultipartPostMethod</literal> using two
      different methods. The first method, <literal
      moreinfo="none">addParameter( )</literal>, adds a <literal
      moreinfo="none">File</literal> object and sets the file name to
      <filename moreinfo="none">test.txt</filename>. The second method,
      <literal moreinfo="none">addPart()</literal>, adds a <literal
      moreinfo="none">FilePart</literal> object to the <literal
      moreinfo="none">MultipartPostMethod</literal>. Both files are sent in
      the request separated by a part boundary, and the script echoes the
      location and type of both files on the server:</para>

      <programlisting format="linespecific" id="I_11_tt452">&lt;h3&gt;Form input&lt;/h3&gt;
&lt;pre&gt;
sample.txt = /tmp/CGI14480.4 sample.txt {text/plain; charset=ISO-8859-1}

test.txt = /tmp/CGI14480.2 test.txt {application/octet-stream; 
charset=ISO-8859-1}
&lt;/pre&gt;</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Adding a part as a <literal moreinfo="none">FilePart</literal>
      <indexterm id="http-webdav-ITERM-3272" significance="normal">
          <primary>FilePart</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3273"
          significance="normal">
          <primary>adding</primary>

          <secondary>parts</secondary>
        </indexterm> <indexterm id="http-webdav-ITERM-3274"
          significance="normal">
          <primary>parts, adding</primary>
        </indexterm> object allows you to specify the <indexterm
          id="http-webdav-ITERM-3275" significance="normal">
          <primary>Multipurpose Internet Main Extensions (MIME)</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3276"
          significance="normal">
          <primary>MIME (Multipurpose Internet Main Extensions)</primary>
        </indexterm>Multipurpose Internet Main Extensions (MIME) type and the
      character set of the part. In this example, the <filename
      moreinfo="none">sample.txt</filename> file is added with a <filename
      moreinfo="none">text/plain</filename> MIME type and an <filename
      moreinfo="none">ISO-8859-1</filename> character set. If a <literal
      moreinfo="none">File</literal> is added to the method using <literal
      moreinfo="none">addParameter( )</literal> or <literal
      moreinfo="none">setParameter( )</literal>, it is sent with the default
      <filename moreinfo="none">application/octet-stream</filename> type and
      the default <filename moreinfo="none">ISO-8859-1</filename> character
      set.</para>

      <para>When <literal moreinfo="none">HttpClient</literal> executes the
      <literal moreinfo="none">MultipartPostMethod</literal> created in the
      previous example, the following request is sent to the server. The
      <filename moreinfo="none">Content-Type</filename> header is <filename
      moreinfo="none">multipart/form-data</filename>, and an arbitrary
      <filename moreinfo="none">boundary</filename> is created to delineate
      multiple parts being sent in the request:</para>

      <programlisting format="linespecific" id="I_11_tt453">POST /cgi-bin/cgi.tcl/echo.cgi HTTP/1.1
User-Agent: Jakarta Commons-HttpClient/3.0final
Host: ats.nist.gov
Content-Length: 498
Content-Type: multipart/form-data; boundary=----------------31415926535
8979323846

------------------314159265358979323846
Content-Disposition: form-data; name=test.txt; filename=test.txt
Content-Type: application/octet-stream; charset=ISO-8859-1
Content-Transfer-Encoding: binary

This is a test.
------------------314159265358979323846
Content-Disposition: form-data; name=sample.txt; filename=sample.txt
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: binary

This is a sample
------------------314159265358979323846--</programlisting>

      <para>Each part contains a <filename
      moreinfo="none">Content-Disposition</filename> header to name the part
      and a <filename moreinfo="none">Content-Type</filename> header to
      classify the part with a MIME type and character set.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>RFC 1867 (form-based file upload in HTML defines a multipart POST)
      can be found at <ulink
      url="http://www.zvon.org/tmRFC/RFC1867/Output/index.html">http://www.zvon.org/tmRFC/RFC1867/Output/index.html</ulink>.
      Each part is sent using MIME, which is described in RFC 2045,
      Multipurpose Internet Mail Extensions (MIME) Part One: Format of
      Internet Message Bodies (<ulink
      url="http://www.zvon.org/tmRFC/RF2045/Output/index.html">http://www.zvon.org/tmRFC/RF2045/Output/index.html</ulink>).</para>
    </sect2>
  </sect1>

  <sect1 id="http-webdav-sect-basic-auth" label="11.10" role="Recipe">
    <title>Basic Authentication</title>

    <sect2>
      <title>Problem</title>

      <para>You need to access information<indexterm class="startofrange"
          id="http-webdav-ITERM-3277" significance="normal">
          <primary>HttpClient</primary>

          <secondary>authentication</secondary>
        </indexterm> <indexterm class="startofrange"
          id="http-webdav-ITERM-3278" significance="normal">
          <primary>authentication</primary>

          <secondary>HttpClient</secondary>
        </indexterm> <indexterm class="startofrange"
          id="http-webdav-ITERM-3279" significance="normal">
          <primary>clients</primary>

          <secondary>HttpClient</secondary>

          <tertiary>authentication</tertiary>
        </indexterm> protected by HTTP Basic Authentication.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Create a <literal
      moreinfo="none">UsernamePasswordCredentials</literal> <indexterm
          id="http-webdav-ITERM-3280" significance="normal">
          <primary>UsernamePasswordCredentials object</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3281"
          significance="normal">
          <primary>objects</primary>

          <secondary>UsernamePasswordCredentials</secondary>
        </indexterm> object with a username and password. Add this <literal
      moreinfo="none">Credentials</literal> object to the instance of <literal
      moreinfo="none">HttpState</literal> associated with an <literal
      moreinfo="none">HttpClient</literal> object. <literal
      moreinfo="none">HttpClient</literal> will attempt to execute a message,
      and the server will respond with <literal moreinfo="none">401</literal>
      response code; <literal moreinfo="none">HttpClient</literal> will then
      retry the request with<indexterm id="http-webdav-ITERM-3282"
          significance="normal">
          <primary>authorization, headers</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3283"
          significance="normal">
          <primary>headers</primary>

          <secondary>authorization</secondary>
        </indexterm> the appropriate <filename
      moreinfo="none">Authorization</filename> header. The following example
      uses a <literal moreinfo="none">UsernamePasswordCredentials</literal>
      object to access a protected resource:</para>

      <programlisting format="linespecific" id="I_11_tt454">
               <userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.Credentials;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpClient;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpException;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpMethod;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.UsernamePasswordCredentials;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.methods.GetMethod;

HttpClient client = new HttpClient( );
HttpState state = client.getState( );
    
// Set credentials on the client
Credentials credentials =
     new UsernamePasswordCredentials( "testuser", "crazypass" );
state.setCredentials( null, null, credentials );

String url = "http://www.discursive.com/jccook/auth/";
HttpMethod method = <userinput moreinfo="none">new</userinput> GetMethod( url );
    
client.executeMethod( method );
String response = method.getResponseBodyAsString( );

System.out.println( response );
method.releaseConnection( );</programlisting>

      <para>This example executes a <literal
      moreinfo="none">GetMethod</literal>, the server requests <indexterm
          id="http-webdav-ITERM-3284" significance="normal">
          <primary>credentials</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3285"
          significance="normal">
          <primary>servers</primary>

          <secondary>authentication</secondary>
        </indexterm>credentials, and the credentials are sent to the server.
      The final response is:</para>

      <programlisting format="linespecific" id="I_11_tt455">&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;Secure JCCook Example&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;h1&gt;Hello Secure World!&lt;/h1&gt;
 &lt;/body&gt;
&lt;/html&gt;</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>The previous example added a <literal
      moreinfo="none">UsernamePasswordCredentials</literal> object to the
      <literal moreinfo="none">HttpState</literal> with a <literal
      moreinfo="none">null</literal> authentication realm and a <literal
      moreinfo="none">null</literal> host; this makes the supplied <literal
      moreinfo="none">UsernamePasswordCredentials</literal> object the default
      instance to use for all authentication realms and hosts. The requests
      and responses created by this example demonstrate the inner-workings of
      <literal moreinfo="none">HttpClient</literal>, which sent the following
      request when the <literal moreinfo="none">GetMethod</literal> was
      executed:</para>

      <programlisting format="linespecific" id="I_11_tt456">GET /jccook/auth/ HTTP/1.1
User-Agent: Jakarta Commons-HttpClient/3.0final
Host: www.discursive.com</programlisting>

      <para>The server then responds with a <literal
      moreinfo="none">401</literal> response code, telling the client that
      authorization is required. The <filename
      moreinfo="none">WWW-Authenticate</filename> <indexterm
          id="http-webdav-ITERM-3286" significance="normal">
          <primary>WWW-Authenticate header</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3287"
          significance="normal">
          <primary>headers</primary>

          <secondary>WWW-Authenticate</secondary>
        </indexterm> header specifies that the server is expecting Basic
      authentication, and the authentication realm is <filename
      moreinfo="none">jccook realm</filename>:</para>

      <programlisting format="linespecific" id="I_11_tt457">HTTP/1.1 401 Authorization Required
Date: Fri, 14 May 2004 20:40:59 GMT
Server: Apache/2.0.48 (Fedora)
WWW-Authenticate: Basic realm="jccook realm"
Content-Length: 487
Content-Type: text/html; charset=iso-8859-1
DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;
&lt;html&gt;&lt;head&gt;
title&gt;401 Authorization Required&lt;/title&gt;
&lt;/head&gt;&lt;body&gt;
.... error message ....</programlisting>

      <para>The server did not return the information needed, and another
      request needs to be made, sending the credentials in an <filename
      moreinfo="none">Authorization</filename> request header. Since the
      initial request was made with <filename
      moreinfo="none">HTTP/1.1</filename>, the connection is not closed after
      the response, and a second request will be sent over the same
      connection. This second request is the same as the first request except
      for an <filename moreinfo="none">Authorization</filename> header.
      <literal moreinfo="none">HttpClient</literal> looked at the associated
      <literal moreinfo="none">HttpState</literal> object and located the
      appropriate <literal moreinfo="none">Credentials</literal> object to use
      to create the <filename moreinfo="none">Authorization</filename>
      header:</para>

      <programlisting format="linespecific" id="I_11_tt458">GET /jccook/auth/ HTTP/1.1
User-Agent: Jakarta Commons-HttpClient/3.0final
Host: www.discursive.com
Authorization: Basic dGVzdHVzZXI6Y3JhenlwYXNz</programlisting>

      <para>Finally, the server replies with a <literal
      moreinfo="none">200</literal> response code and the content of the
      requested resource:</para>

      <programlisting format="linespecific" id="I_11_tt459">HTTP/1.1 200 OK
Date: Fri, 14 May 2004 20:40:59 GMT
Server: Apache/2.0.48 (Fedora)
Last-Modified: Wed, 05 May 2004 02:51:59 GMT
ETag: "a06d2-76-829811c0"
Accept-Ranges: bytes
Content-Length: 118
Content-Type: text/html; charset=UTF-8
&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;Secure JCCook Example&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;h1&gt;Hello Secure World!&lt;/h1&gt;
 &lt;/body&gt;
&lt;/html&gt;</programlisting>

      <para><literal moreinfo="none">HttpClient</literal> waits for the server
      to send back a <filename moreinfo="none">401</filename> response code
      before sending the appropriate credentials. If you are accessing a
      resource, which is known to be protected by authentication, you can
      configure the <literal moreinfo="none">HttpState</literal> object to
      send credentials preemptively, obviating the need for the client to
      react to a <filename moreinfo="none">401</filename> response code. In
      other words, the <filename moreinfo="none">Authorization</filename>
      header is supplied in the initial request. To configure <literal
      moreinfo="none">HttpClient</literal> to send credentials preemptively,
      retrieve an <literal moreinfo="none">HttpClientParams</literal> object
      from <literal moreinfo="none">HttpClient</literal> via the <literal
      moreinfo="none">getParams( )</literal> method, and call <literal
      moreinfo="none">setAuthenticationPreemptive(true)</literal> as
      follows:</para>

      <programlisting format="linespecific" id="I_11_tt460">HttpClientParams params = client.getParams( );

params.setAuthenticationPreemptive( <userinput moreinfo="none">true</userinput> );</programlisting>

      <warning id="http-webdav-NOTE-73" role="ora">
        <para>Basic authentication involves sending an unencrypted password in
        the request. The value of the <filename
        moreinfo="none">Authorization</filename> header in the request is
        simply <literal moreinfo="none">testuser:crazypass</literal> sent
        through a <literal moreinfo="none">Base64</literal> encoding utility.
        If you are working on a system that uses Basic authentication, make
        sure that any system that performs authentication does so over
        <filename moreinfo="none">SSL</filename>; otherwise, your password
        will fall into the wrong hands.</para>
      </warning>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>If you want to convince someone that <indexterm class="endofrange"
      id="http-webdav-ITERM-3288" significance="normal"
      startref="http-webdav-ITERM-3277"></indexterm> <indexterm
      class="endofrange" id="http-webdav-ITERM-3289" significance="normal"
      startref="http-webdav-ITERM-3278"></indexterm> <indexterm
      class="endofrange" id="http-webdav-ITERM-3290" significance="normal"
      startref="http-webdav-ITERM-3279"></indexterm>using Basic authentication
      without encryption is a bad idea, download the network protocol analyzer
      Ethereal (<ulink
      url="http://www.ethereal.com/">http://www.ethereal.com/</ulink>), and
      capture some network traffic. Identify an <filename
      moreinfo="none">Authorize</filename> header and run the value through a
      Base64 decoder (<ulink
      url="http://www.securitystats.com/tools/base64.php">http://www.securitystats.com/tools/base64.php</ulink>).
      Create a custom T-shirt or coffee mug with your friend's username and
      password, and present it to him as a gift.</para>
    </sect2>
  </sect1>

  <sect1 id="http-webdav-sect-ntlm-auth" label="11.11" role="Recipe">
    <title>NTLM Authentication</title>

    <sect2>
      <title>Problem</title>

      <para>You need to access a resource that is protected by Microsoft's
      NTLM authentication protocol.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Create an instance of <literal
      moreinfo="none">NTCredentials</literal> with a username, password, host,
      and domain, and call <literal moreinfo="none">setCredentials()</literal>
      <indexterm id="http-webdav-ITERM-3291" significance="normal">
          <primary>setCredentials( ) method</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3292"
          significance="normal">
          <primary>methods</primary>

          <secondary>setCredentials( )</secondary>
        </indexterm> on the <literal moreinfo="none">HttpState</literal>
      associated with an instance of <literal
      moreinfo="none">HttpClient</literal>. The following example demonstrates
      the use of <literal moreinfo="none">NTCredentials</literal> to access a
      resource on host <filename
      moreinfo="none">test.windowsmachine.com</filename>, which is on the
      domain <filename moreinfo="none">TESTDOM</filename>:</para>

      <programlisting format="linespecific" id="I_11_tt461">
               <userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.Credentials;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpClient;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpState;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpException;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpMethod;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.NTCredentials;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.methods.GetMethod;

HttpClient client = <userinput moreinfo="none">new</userinput> HttpClient( );

<emphasis role="bold">// Set credentials on the client</emphasis>
               <emphasis role="bold">Credentials credentials =</emphasis>
               <emphasis role="bold">new NTCredentials( "testuser", "crazypass"</emphasis>, 
                       "<emphasis role="bold">homecomputer ", "TESTDOM" );</emphasis>
               <emphasis role="bold">HttpState state = client.getState( );</emphasis>
               <emphasis role="bold">state( ).setCredentials( null, null, credentials );</emphasis>

String url = "http://webmail.domain.biz/exchange/";
HttpMethod method = <userinput moreinfo="none">new</userinput> GetMethod( url );
    
client.executeMethod( method );
String response = method.getResponseBodyAsString( );

System.out.println( response );
method.releaseConnection( );</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>The parameters to the constructor of <literal
      moreinfo="none">NTCredentials</literal> are the username, the password,
      a hostname, and a domain. The hostname is the name of the machine making
      the request, and, in this case, the third parameter is <filename
      moreinfo="none">homecomputer</filename>. When this <literal
      moreinfo="none">Credential</literal> object is set in the <literal
      moreinfo="none">HttpState</literal> object, the first two parameters
      specify the authentication realm and the host to apply a <literal
      moreinfo="none">Credential</literal> object to. The previous example
      sets both the authentication realm and the host to <literal
      moreinfo="none">null</literal>; this makes the <literal
      moreinfo="none">NTCredentials</literal> <indexterm
          id="http-webdav-ITERM-3293" significance="normal">
          <primary>NTCredentials object</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3294"
          significance="normal">
          <primary>objects</primary>

          <secondary>NTCredentials</secondary>
        </indexterm> object the default <literal
      moreinfo="none">Credentials</literal> to use if there is no realm or
      host specified. If we were using one instance of <literal
      moreinfo="none">HttpClient</literal> to connect to two different hosts
      with two different <literal moreinfo="none">NTCredentials</literal>
      objects, both <literal moreinfo="none">Credentials</literal> objects
      could be added to <literal moreinfo="none">HttpState</literal> with the
      following code:</para>

      <programlisting format="linespecific" id="I_11_tt462">HttpClient client = <userinput
          moreinfo="none">new</userinput> HttpClient( );

Credentials credentials1 =
<userinput moreinfo="none">    new</userinput> NTCredentials( "testuser", "crazypass", 
                       "homecomputer", "TESTDOM" );

Credentials credentials2 =
<userinput moreinfo="none">    new</userinput> NTCredentials( "anotheruser", "password2", 
                       "homecomputer", "DIFFERENT_DOMAIN" );

HttpState state = client.getState( );
state( ).setCredentials( <userinput moreinfo="none">null</userinput>, <userinput
          moreinfo="none">"webmail.domain.biz"</userinput>, credentials1 );
state( ).setCredentials( <userinput moreinfo="none">null</userinput>, <userinput
          moreinfo="none">"silly-iis-server.lame.net"</userinput>, credentials2 );

// Execute a request which uses credentials1
String url = "http://webmail.domain.biz/exchange/";
HttpMethod method = <userinput moreinfo="none">new</userinput> GetMethod( url );
client.executeMethod( method );

// Execute a request which uses credentials2
String url2 = "http://silly-iis-server.lame.net/test/";
HttpMethod method2 = <userinput moreinfo="none">new</userinput> GetMethod( url2 );
client.executeMethod( method2 );</programlisting>

      <para>The host <filename moreinfo="none">webmail.domain.biz</filename>
      tries to authenticate the first request against the <filename
      moreinfo="none">TESTDOM</filename> domain, and the <filename
      moreinfo="none">silly-iis-server.lame.net</filename> host tries to
      authenticate the second request against the <filename
      moreinfo="none">DIFFERENT_DOMAIN</filename> domain. Since the <literal
      moreinfo="none">HttpState</literal> is configured with two separate
      <literal moreinfo="none">Credentials</literal> objects for different
      hosts, both requests are successfully authenticated.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>No one will dispute the assertion that the HTTP protocol has
      dramatically changed the world we live in, and one of the reasons for
      this success is the openness of the protocol. Unfortunately, NTLM is
      proprietary and undocumented, and this is reason enough to avoid using
      it entirely. If you are stuck with NTLM and you want to learn more about
      the protocol, it is described in excruciating detail at <ulink
      url="http://www.innovation.ch/java/ntlm.html">http://www.innovation.ch/java/ntlm.html</ulink>
      and <ulink
      url="http://davenport.sourceforge.net/ntlm.html">http://davenport.sourceforge.net/ntlm.html</ulink>.</para>
    </sect2>
  </sect1>

  <sect1 id="http-webdav-sect-cookies" label="11.12" role="Recipe">
    <title>Working with Cookies</title>

    <sect2>
      <title>Problem</title>

      <para>You need to work with <indexterm class="startofrange"
          id="http-webdav-ITERM-3295" significance="normal">
          <primary>HttpClient</primary>

          <secondary>cookies</secondary>
        </indexterm> <indexterm class="startofrange"
          id="http-webdav-ITERM-3296" significance="normal">
          <primary>cookies, HttpClient</primary>
        </indexterm> <indexterm class="startofrange"
          id="http-webdav-ITERM-3297" significance="normal">
          <primary>clients</primary>

          <secondary>HttpClient</secondary>

          <tertiary>cookies</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="http-webdav-ITERM-3298" significance="normal">
          <primary>tracking</primary>

          <secondary>cookies</secondary>
        </indexterm> <indexterm class="startofrange"
          id="http-webdav-ITERM-3299" significance="normal">
          <primary>servers</primary>

          <secondary>cookies</secondary>
        </indexterm>a system that uses cookies to store state, and you need to
      be able to set cookies as well as keep track of cookies set by the
      server.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para><literal moreinfo="none">HttpClient</literal> handles cookies
      automatically. If you need to keep track of a cookie set by the server,
      simply use the same instance of <literal
      moreinfo="none">HttpClient</literal> for each request in a session. If
      you need to set a cookie, create an instance of <literal
      moreinfo="none">Cookie</literal>, and add it to <literal
      moreinfo="none">HttpState</literal>. The following example sends a
      <literal moreinfo="none">Cookie</literal> to the server:</para>

      <programlisting format="linespecific" id="I_11_tt463">
               <userinput moreinfo="none">import</userinput> java.io.IOException;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.Cookie;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpClient;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpException;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpMethod;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.methods.GetMethod;

HttpClient client = <userinput moreinfo="none">new</userinput> HttpClient( );
    
System.out.println( "Making Request without Cookie: " );
makeRequest(client);
            
System.out.println( "Making Request with Cookie: " );
Cookie cookie = <userinput moreinfo="none">new</userinput> Cookie(".discursive.com", "test_cookie", 
                           "hello", "/", null, <userinput moreinfo="none">false</userinput> );
client.getState( ).addCookie( cookie );
makeRequest(client);

<userinput moreinfo="none">private</userinput> 
               <userinput moreinfo="none">static</userinput> 
               <userinput moreinfo="none">void</userinput> makeRequest(HttpClient client)
<userinput moreinfo="none">    throws</userinput> IOException, HttpException {
    String url = "http://www.discursive.com/cgi-bin/jccook/cookie_test.cgi";
    HttpMethod method = <userinput moreinfo="none">new</userinput> GetMethod( url );
    client.executeMethod( method );
    String response = method.getResponseBodyAsString( );
    System.out.println( response );
    method.releaseConnection( );
    method.recycle( );
}</programlisting>

      <para>This example hits a CGI script that tests for the presence of a
      cookie named <filename moreinfo="none">test_cookie</filename>. One
      request is made without the cookie and another request is made with the
      cookie. The following output is produced:</para>

      <programlisting format="linespecific" id="I_11_tt464">Making Request without Cookie: 
&lt;h1&gt;test_cookie NOT PRESENT&lt;/h1&gt;

Making Request with Cookie: 
&lt;h1&gt;test_cookie PRESENT&lt;/h1 &gt;</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Cookies are used by a number of application servers to manage user
      sessions; <filename moreinfo="none">JSESSIONID</filename> cookies are
      used by most J2EE application servers and servlet containers to keep
      track of a session. Because <literal
      moreinfo="none">HttpClient</literal> automatically handles cookies, if a
      server sets a cookie, it will be added to the <literal
      moreinfo="none">HttpState</literal> instance associated with <literal
      moreinfo="none">HttpClient</literal>. If you need to get a list of
      cookies associated with an <literal moreinfo="none">HttpState</literal>,
      call <literal moreinfo="none">getCookies( )</literal> to obtain an array
      of <literal moreinfo="none">Cookie</literal> objects. The following code
      retrieves an array of <literal moreinfo="none">Cookie</literal> objects,
      printing the <literal moreinfo="none">domain</literal>, <literal
      moreinfo="none">path</literal>, <literal moreinfo="none">name</literal>,
      and <literal moreinfo="none">value</literal> of each <literal
      moreinfo="none">Cookie</literal>:</para>

      <programlisting format="linespecific" id="I_11_tt465">HttpClient client = new HttpClient( );

// execute some methods...

Cookie[] cookies = client.getState( ).getCookies( );
for( int i = 0; i &lt; cookies; i++ ) {
    Cookie cookie = cookies[i];
    String domain = cookie.getDomain( );
    String path = cookie.getPath( );
    String name = cookie.getName( );
    String value = cookie.getValue( );
    System.out.println( "Cookie: " + domain + ", " + path + ", " +
                        name + ", " + value );
}</programlisting>

      <para>There are two different approaches to cookies floating around the
      internet: <indexterm id="http-webdav-ITERM-3300" significance="normal">
          <primary>Netscape Draft Specification</primary>
        </indexterm>Netscape Draft Specification and <indexterm
          id="http-webdav-ITERM-3301" significance="normal">
          <primary>RFC 2109</primary>
        </indexterm>RFC 2109. Some servers use the Netscape Draft and others
      use RFC 2109; because of this, HttpClient offers a <literal
      moreinfo="none">COMPATIBILITY</literal> <indexterm
          id="http-webdav-ITERM-3302" significance="normal">
          <primary>COMPATIBILITY mode</primary>
        </indexterm> mode that should work with most servers. The default
      cookie policy for HttpClient is the <literal
      moreinfo="none">RFC_2109</literal> policy. If you are having problems
      with cookies, change the cookie policy to the <literal
      moreinfo="none">COMPATIBILITY</literal> policy, which is a public static
      <literal moreinfo="none">int</literal> in the <literal
      moreinfo="none">CookiePolicy</literal> class. To change the cookie
      policy, call <literal moreinfo="none">setCookiePolicy()</literal>
      <indexterm id="http-webdav-ITERM-3303" significance="normal">
          <primary>setCookiePolicy( ) method</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3304"
          significance="normal">
          <primary>methods</primary>

          <secondary>setCookiePolicy( )</secondary>
        </indexterm> on the <literal moreinfo="none">HttpState</literal>
      associated with <literal moreinfo="none">HttpClient</literal>, as
      follows:</para>

      <programlisting format="linespecific" id="I_11_tt466">HttpClient client = new HttpClient( );

// To use a Compatability policy
client.getState( ).setCookiePolicy(CookiePolicy.COMPATIBILITY);

// To use a Netscape Draft policy
client.getState( ).setCookiePolicy(CookiePolicy.NETSCAPE_DRAFT);

// To use a RFC 2109 policy - this is the default
client.getState( ).setCookiePolicy(CookiePolicy.RFC2109);</programlisting>

      <para>There is also a third approach—outlined in RFC 2965—which
      supercedes RFC 2109. However, there is no code-level support for this
      third approach in commons yet.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>The original cookie specification was <indexterm
      class="endofrange" id="http-webdav-ITERM-3305" significance="normal"
      startref="http-webdav-ITERM-3295"></indexterm> <indexterm
      class="endofrange" id="http-webdav-ITERM-3306" significance="normal"
      startref="http-webdav-ITERM-3296"></indexterm> <indexterm
      class="endofrange" id="http-webdav-ITERM-3307" significance="normal"
      startref="http-webdav-ITERM-3297"></indexterm> <indexterm
      class="endofrange" id="http-webdav-ITERM-3308" significance="normal"
      startref="http-webdav-ITERM-3298"></indexterm> <indexterm
      class="endofrange" id="http-webdav-ITERM-3309" significance="normal"
      startref="http-webdav-ITERM-3299"></indexterm>written by Netscape, and
      it can be found at <ulink
      url="http://wp.netscape.com/newsref/std/cookie_spec.html">http://wp.netscape.com/newsref/std/cookie_spec.html</ulink>.
      RFC 2109 (HTTP State Management Mechanism) is available at <ulink
      url="http://www.zvon.org/tmRFC/RFC2109/Output/">http://www.zvon.org/tmRFC/RFC2109/Output/</ulink>,
      and the newer RFC 2965 (HTTP State Management Mechanism) can be found at
      <ulink
      url="http://www.zvon.org/tmRFC/RFC2965/Output/">http://www.zvon.org/tmRFC/RFC2965/Output/</ulink>.
      Currently, HttpClient does not support the RFC 2965 standard.</para>
    </sect2>
  </sect1>

  <sect1 id="http-webdav-sect-handle-redirect" label="11.13" role="Recipe">
    <title>Handling Redirects</title>

    <sect2>
      <title>Problem</title>

      <para>You need to access a server that<indexterm class="startofrange"
          id="http-webdav-ITERM-3310" significance="normal">
          <primary>HttpClient</primary>

          <secondary>redirects</secondary>
        </indexterm> <indexterm class="startofrange"
          id="http-webdav-ITERM-3311" significance="normal">
          <primary>redirects, HttpClient</primary>
        </indexterm> <indexterm class="startofrange"
          id="http-webdav-ITERM-3312" significance="normal">
          <primary>clients</primary>

          <secondary>HttpClient</secondary>

          <tertiary>redirects</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="http-webdav-ITERM-3313" significance="normal">
          <primary>sending</primary>

          <secondary>redirects</secondary>
        </indexterm> may send an arbitrary number of redirects.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Before executing an <literal moreinfo="none">HttpMethod</literal>
      call, <literal moreinfo="none">setFollowRedirects(true)</literal>
      <indexterm id="http-webdav-ITERM-3314" significance="normal">
          <primary>setFollowRedirects( ) method</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3315"
          significance="normal">
          <primary>methods</primary>

          <secondary>setFollowRedirects( )</secondary>
        </indexterm> on the method; <literal
      moreinfo="none">HttpClient</literal> will take care of following any
      redirects a server may return in a response. The following example shows
      what happens when a method requests a CGI script that returns a <literal
      moreinfo="none">302</literal> (moved temporarily) response code:</para>

      <programlisting format="linespecific" id="I_11_tt467">
               <userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpClient;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpException;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpMethod;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.methods.GetMethod;

HttpClient client = <userinput moreinfo="none">new</userinput> HttpClient( );
String url = "http://www.discursive.com/cgi-bin/jccook/redirect.cgi";
    
System.out.println( "Executing Method not following redirects: ");        
HttpMethod method = <userinput moreinfo="none">new</userinput> GetMethod( url );
method.setFollowRedirects( <userinput moreinfo="none">false</userinput> );
executeMethod(client, method);

System.out.println( "Executing Method following redirects: ");        
method = new GetMethod( url );
method.setFollowRedirects( <userinput moreinfo="none">true</userinput> );
executeMethod(client, method);

<userinput moreinfo="none">private</userinput> 
               <userinput moreinfo="none">static</userinput> 
               <userinput moreinfo="none">void</userinput> executeMethod(HttpClient client, HttpMethod method)
<userinput moreinfo="none">    throws</userinput> IOException, HttpException {
    client.executeMethod( method );
    System.out.println( "Response Code: " + method.getStatusCode( ) );
    String response = method.getResponseBodyAsString( );
    System.out.println( response );
    method.releaseConnection( );
    method.recycle( );
}</programlisting>

      <para>This example executes two <literal
      moreinfo="none">GetMethod</literal> instances; the first method is
      configured <emphasis role="bold">not</emphasis> to follow redirects, and
      the second is configured to follow redirects. The first method is
      executed, and the server sends a <literal moreinfo="none">302</literal>
      response code. Since this method is not configured to follow redirects,
      <literal moreinfo="none">HttpClient</literal> does not make another
      request. When the second method is executed, <literal
      moreinfo="none">HttpClient</literal> follows the initial redirect to a
      <filename moreinfo="none">redirect2.cgi</filename> script, which sends
      another redirect to <filename
      moreinfo="none">/jccook/index.html</filename>:</para>

      <programlisting format="linespecific" id="I_11_tt468">Executing Method not following redirects: 
0    INFO  [main] org.apache.commons.httpclient.HttpMethodBase     - Redirect 
requested but followRedirects is disabled
Response Code: 302

Executing Method following redirects: 
Response Code: 200
&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;JCCook Example&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;h1&gt;Hello World!&lt;/h1&gt;
 &lt;/body&gt;
&lt;/html&gt;</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para><literal moreinfo="none">HttpClient</literal> can handle any of
      the following <indexterm id="http-webdav-ITERM-3316"
          significance="normal">
          <primary>response codes, redirects</primary>
        </indexterm>response codes specifying a redirect:</para>

      <itemizedlist>
        <listitem>
          <para>Status Code 302: <literal
          moreinfo="none">HttpStatus.SC_MOVED_TEMPORARILY</literal></para>
        </listitem>

        <listitem>
          <para>Status Code 301: <literal
          moreinfo="none">HttpStatus.SC_MOVED_PERMANENTLY</literal></para>
        </listitem>

        <listitem>
          <para>Status Code 303: <literal
          moreinfo="none">HttpStatus.SC_SEE_OTHER</literal></para>
        </listitem>

        <listitem>
          <para>Status Code 307: <literal
          moreinfo="none">HttpStatus.SC_TEMPORARY_REDIRECT</literal></para>
        </listitem>
      </itemizedlist>

      <para>When a response code is retrieved, <literal
      moreinfo="none">HttpClient</literal> sends another GET request for the
      resource specified in the <filename moreinfo="none">Location</filename>
      header. The following code is the first request sent by a method
      configured to<indexterm id="http-webdav-ITERM-3317"
          significance="normal">
          <primary>configuration</primary>

          <secondary>redirects</secondary>
        </indexterm> follow redirects:</para>

      <programlisting format="linespecific" id="I_11_tt469">GET /cgi-bin/jccook/redirect.cgi HTTP/1.1
User-Agent: Jakarta Commons-HttpClient/3.0final
Host: www.discursive.com</programlisting>

      <para>The <filename moreinfo="none">redirect.cgi</filename> <indexterm
          id="http-webdav-ITERM-3318" significance="normal">
          <primary>scripts</primary>

          <secondary>redirect.cgi</secondary>
        </indexterm> script will then send a <literal moreinfo="none">302
      Moved</literal> response, supplying a <filename
      moreinfo="none">Location</filename> <indexterm
          id="http-webdav-ITERM-3319" significance="normal">
          <primary>Location headers</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3320"
          significance="normal">
          <primary>headers</primary>

          <secondary>Location</secondary>
        </indexterm> header that points to <filename
      moreinfo="none">redirect2.cgi</filename>:</para>

      <programlisting format="linespecific" id="I_11_tt470">HTTP/1.1 302 Moved
Date: Sat, 15 May 2004 19:30:49 GMT
Server: Apache/2.0.48 (Fedora)
Location: /cgi-bin/jccook/redirect2.cgi
Content-Length: 0
Content-Type: text/plain; charset=UTF-8</programlisting>

      <para><literal moreinfo="none">HttpClient</literal> then sends another
      GET request for the resource specified in the previous response:</para>

      <programlisting format="linespecific" id="I_11_tt471">GET /cgi-bin/jccook/redirect2.cgi HTTP/1.1
User-Agent: Jakarta Commons-HttpClient/3.0final
Host: www.discursive.com</programlisting>

      <para>The <filename moreinfo="none">redirect2.cgi</filename> is
      configured to send a redirect for <filename
      moreinfo="none">/jccook/index.html</filename>, and the response to the
      previous request does just that:</para>

      <programlisting format="linespecific" id="I_11_tt472">HTTP/1.1 302 Moved
Date: Sat, 15 May 2004 19:30:49 GMT
Server: Apache/2.0.48 (Fedora)
Location: /jccook/index.html
Content-Length: 0
Content-Type: text/plain; charset=UTF-8</programlisting>

      <para>How <literal moreinfo="none">HttpClient</literal> handles redirect
      responses can be further customized by three configurable parameters on
      <literal moreinfo="none">HttpClient</literal>. <literal
      moreinfo="none">REJECT_RELATIVE_REDIRECT</literal> causes <literal
      moreinfo="none">HttpClient</literal> to throw an exception if a server
      sends a <filename moreinfo="none">Location</filename> header with a
      relative URL; for instance, if the <filename
      moreinfo="none">redirect.cgi</filename> script returns a <filename
      moreinfo="none">Location</filename> header of <filename
      moreinfo="none">../index.html</filename>, the redirection causes an
      exception if <literal moreinfo="none">REJECT_RELATIVE_REDIRECT</literal>
      is set to <literal moreinfo="none">true</literal>. If <literal
      moreinfo="none">ALLOW_CIRCULAR_REDIRECTS</literal> is set to <literal
      moreinfo="none">true</literal>, <literal
      moreinfo="none">HttpClient</literal> throws an exception if a series of
      redirects includes the same resources more than once. <literal
      moreinfo="none">MAX_REDIRECTS</literal> allows you to specify a maximum
      number of redirects to follow. The following example sets all three
      parameters on an instance of <literal
      moreinfo="none">HttpClientParams</literal> associated with an instance
      of <literal moreinfo="none">HttpClient</literal>:</para>

      <programlisting format="linespecific" id="I_11_tt473">HttpClient client = new HttpClient( );
HttpClientParams params = client.getParams( );

params.setBooleanParameter( HttpClientParams.REJECT_RELATIVE_REDIRECT, false );
params.setBooleanParameter( HttpClientParams.ALLOW_CIRCULAR_REDIRECTS, false );
params.setIntParameter( HttpClientParams.MAX_REDIRECTS, 10 );</programlisting>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>For more information on how <literal
      moreinfo="none">HttpClient</literal> <indexterm class="endofrange"
      id="http-webdav-ITERM-3321" significance="normal"
      startref="http-webdav-ITERM-3310"></indexterm> <indexterm
      class="endofrange" id="http-webdav-ITERM-3322" significance="normal"
      startref="http-webdav-ITERM-3311"></indexterm> <indexterm
      class="endofrange" id="http-webdav-ITERM-3323" significance="normal"
      startref="http-webdav-ITERM-3312"></indexterm> <indexterm
      class="endofrange" id="http-webdav-ITERM-3324" significance="normal"
      startref="http-webdav-ITERM-3313"></indexterm> handles redirection, take
      a look at the source for the<indexterm id="http-webdav-ITERM-3325"
          significance="normal">
          <primary>HttpMethodDirector</primary>
        </indexterm> <literal moreinfo="none">HttpMethodDirector</literal>.
      The <literal moreinfo="none">isRedirectNeeded()</literal> <indexterm
          id="http-webdav-ITERM-3326" significance="normal">
          <primary>isRedirectNeeded( ) method</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3327"
          significance="normal">
          <primary>methods</primary>

          <secondary>isRedirectNeeded( )</secondary>
        </indexterm> and <literal
      moreinfo="none">processRedirectResponse()</literal> <indexterm
          id="http-webdav-ITERM-3328" significance="normal">
          <primary>processRedirectResponse( ) method</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3329"
          significance="normal">
          <primary>methods</primary>

          <secondary>processRedirectResponse( )</secondary>
        </indexterm> methods handle redirection, and the source for this class
      can be viewed using ViewCVS (<ulink
      url="http://cvs.apache.org/viewcvs.cgi/jakarta-commons/httpclient/src/java/">http://cvs.apache.org/viewcvs.cgi/jakarta-commons/httpclient/src/java/</ulink>).
      Navigate to the <literal
      moreinfo="none">org.apache.commons.httpclient</literal> package and
      click on <literal moreinfo="none">HttpMethodDirector</literal>.</para>
    </sect2>
  </sect1>

  <sect1 id="http-webdav-sect-ssl" label="11.14" role="Recipe">
    <title>SSL</title>

    <sect2>
      <title>Problem</title>

      <para>You need to execute a <indexterm id="http-webdav-ITERM-3330"
          significance="normal">
          <primary>HttpClient</primary>

          <secondary>SSL</secondary>
        </indexterm> <indexterm id="http-webdav-ITERM-3331"
          significance="normal">
          <primary>SSL (Secure Sockets Layer)</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3332"
          significance="normal">
          <primary>clients</primary>

          <secondary>HttpClient</secondary>

          <tertiary>SSL</tertiary>
        </indexterm>method using HTTP over <indexterm
          id="http-webdav-ITERM-3333" significance="normal">
          <primary>Secure Sockets Layer</primary>

          <see>SSL</see>
        </indexterm>Secure Sockets Layer (SSL).</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>If you are working with a server that has a certificate signed by
      a certificate authority included in the Java Secure Socket Extension
      (JSSE), <literal moreinfo="none">HttpClient</literal> automatically
      handles HTTP over SSL; just use a URL that <indexterm
          id="http-webdav-ITERM-3334" significance="normal">
          <primary>URLs (uniform resource locators)</primary>

          <secondary>SSL</secondary>
        </indexterm>starts with <filename moreinfo="none">https</filename>.
      The following example retrieves Amazon.com's sign-in page using HTTP
      over SSL:</para>

      <programlisting format="linespecific" id="I_11_tt474">
               <userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpClient;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpException;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpMethod;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.methods.GetMethod;

HttpClient client = <userinput moreinfo="none">new</userinput> HttpClient( );
String url = "https://www.amazon.com/gp/flex/sign-in.html";

HttpMethod method = <userinput moreinfo="none">new</userinput> GetMethod( url );
client.executeMethod( method );

String response = method.getResponseBodyAsString( );
System.out.println( response );

method.releaseConnection( );
method.recycle( );</programlisting>

      <para>This example executes a simple <literal
      moreinfo="none">GetMethod</literal> constructed with a URL starting with
      <filename moreinfo="none">https</filename>. The output of this example
      is:</para>

      <programlisting format="linespecific" id="I_11_tt475">0    WARN  [main] org.apache.commons.httpclient.HttpMethodBase     - Response 
content length is not known
297  WARN  [main] org.apache.commons.httpclient.HttpMethodBase     - Response 
content length is not known
&lt;html&gt;
&lt;head&gt;&lt;title&gt;Amazon.com Sign In&lt;/title&gt;
&lt;/head&gt;
.......... Content ..................
&lt;/html&gt;</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>HttpClient handles SSL automatically, if it can verify the
      authenticity of a certificate against an authority; this is why this
      recipe is so similar to <link linkend="http-webdav-sect-get">Recipe
      11.3</link>. The example in this recipe only works if you are dealing
      with a site that has a certificate signed by a well-known authority. The
      Java Runtime Environment (JRE) keeps track of the signatures of all the
      known certificate authorities in a file named <filename
      moreinfo="none">cacerts</filename>. <filename
      moreinfo="none">cacerts</filename> can be found in <filename
      moreinfo="none">${JAVA_HOME}/jre/lib/security/cacerts</filename>; it is
      an archive that has a default password of <literal
      moreinfo="none">changeit</literal>. For a list of certificate
      authorities in Java, execute the following command line and supply the
      default password:</para>

      <programlisting format="linespecific" id="I_11_tt476">keytool -list -keystore C:\j2sdk1.4.2_04\jre\lib\security\cacerts</programlisting>

      <para>The list will contain certificate fingerprints for Thawte,
      Entrust, Verisign, and other commercial certificate authorities. If you
      wish to use the JSSE without having to write your own <literal
      moreinfo="none">ProtocolSocketFactory</literal>, you need to obtain a
      certificate signed by an authority.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>If you need to work with a self-signed certificate, see the next
      recipe.</para>
    </sect2>
  </sect1>

  <sect1 id="http-webdav-sect-self-signed" label="11.15" role="Recipe">
    <title>Accepting a Self-Signed Certificate</title>

    <sect2>
      <title>Problem</title>

      <para>You need to work with a server <indexterm
          id="http-webdav-ITERM-3335" significance="normal">
          <primary>HttpClient</primary>

          <secondary>self-signed certificates</secondary>
        </indexterm> <indexterm id="http-webdav-ITERM-3336"
          significance="normal">
          <primary>self-signed certificates</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3337"
          significance="normal">
          <primary>clients</primary>

          <secondary>HttpClient</secondary>

          <tertiary>self-signed certificates</tertiary>
        </indexterm> <indexterm id="http-webdav-ITERM-3338"
          significance="normal">
          <primary>certificates, self-signed</primary>
        </indexterm>that is using a self-signed certificate.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Provide a custom <literal
      moreinfo="none">SSLProtocolSocketFactory</literal> <indexterm
          id="http-webdav-ITERM-3339" significance="normal">
          <primary>SSLProtocolSocketFactory</primary>
        </indexterm> that is configured to trust your self-signed certificate.
      A sample implementation of <literal
      moreinfo="none">SSLProtocolSocketFactory</literal> named <literal
      moreinfo="none">EasySSLProtocolSocketFactory</literal> is available via
      HttpClient's CVS repository, and the following example uses it to trust
      a self-signed certificate:</para>

      <programlisting format="linespecific" id="I_11_tt477">
               <userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpClient;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpException;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpMethod;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.contrib.ssl.EasySSLProtocolSocketFactory;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.methods.GetMethod;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.protocol.Protocol;

HttpClient client = <userinput moreinfo="none">new</userinput> HttpClient( );
String url = "https://pericles.symbiont.net/jccook";
        
ProtocolSocketFactory socketFactory =
<userinput moreinfo="none">    new</userinput> EasySSLProtocolSocketFactory( );
Protocol https = <userinput moreinfo="none">new</userinput> Protocol( "https", socketFactory, 443);
Protocol.registerProtocol( "https", https );
        
HttpMethod method = <userinput moreinfo="none">new</userinput> GetMethod( url );
client.executeMethod( method );
String response = method.getResponseBodyAsString( );
System.out.println( response );
method.releaseConnection( );
method.recycle( );</programlisting>

      <para>This executes and accepts the self-signed certificate from
      <filename moreinfo="none">pericles.symbiont.net</filename>:</para>

      <programlisting format="linespecific" id="I_11_tt478">Word up, this page was served using SSL!</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para><literal moreinfo="none">EasySSLProtocolSocketFactory</literal>
      and <literal moreinfo="none">EasyX509TrustManager</literal> can be
      obtained from HttpClient's CVS in the <filename
      moreinfo="none">src/contrib</filename> directory. If you do not want to
      checkout the source code from CVS, you can also obtain these two classes
      from ViewCVS on <filename moreinfo="none">cvs.apache.org</filename>.
      HttpClient's CVS repository can be accessed at <ulink
      url="http://cvs.apache.org/viewcvs.cgi/jakarta-commons/httpclient/">http://cvs.apache.org/viewcvs.cgi/jakarta-commons/httpclient/</ulink>,
      and the two classes are in the <filename
      moreinfo="none">src/contrib/org/apache/commons/httpclient/contrib/ssl</filename>
      directory. To use these classes, you must integrate them into your own
      project, customizing the behavior of these classes as you see
      fit.</para>

      <!--TODO: You need to fix this to point to the SVN Repo for Http Client-->

      <para><literal moreinfo="none">EasySSLProtocolSocketFactory</literal>
      uses the <literal moreinfo="none">EasyX509TrustManager</literal> to
      validate a certificate. To customize the criteria for certificate
      acceptance and alter the implementation of <literal
      moreinfo="none">EasyX509TrustManager</literal>. For example, if you only
      want to accept a certificate from a specific hostname, change the
      implementation of the <literal
      moreinfo="none">isServerTrusted()</literal> method in <literal
      moreinfo="none">EasyX509TrustManager</literal>.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>In the same package as <literal
      moreinfo="none">EasySSLProtocolSocketFactory</literal> and <literal
      moreinfo="none">EasyX509TrustManager</literal> is an implementation of
      <literal moreinfo="none">SSLProtocolSocketFactory</literal> named
      <literal moreinfo="none">StrictSSLProtocolSocketFactory</literal>, which
      makes sure that the hostname of the SSL server matches the hostname of
      the SSL certificate. For more information, go to HttpClient's CVS
      repository (<ulink
      url="http://cvs.apache.org/viewcvs.cgi/jakarta-commons/httpclient/">http://cvs.apache.org/viewcvs.cgi/jakarta-commons/httpclient/</ulink>)
      and download <literal
      moreinfo="none">StrictSSLProtocolSocketFactory</literal> from this
      <filename
      moreinfo="none">src/contrib/org/apache/commons/httpclient/contrib/ssl</filename>
      directory.</para>
    </sect2>
  </sect1>

  <sect1 id="http-webdav-sect-obtaining-slide" label="11.16" role="Recipe">
    <title>Obtaining Jakarta Slide</title>

    <warning>
      <para>Slide has died. While this section remains in the book, you should
      know that it will soon be replaced with a section devoted to <ulink
      url="http://jackrabbit.apache.org/">Apache Jackrabbit</ulink>: the
      successor to Jakarta Slide.</para>
    </warning>

    <sect2>
      <title>Problem</title>

      <para>You need to use Jakarta Slide to access a Web-based Distributed
      Authoring and Versioning (<indexterm id="http-webdav-ITERM-3340"
          significance="normal">
          <primary>WebDav</primary>

          <secondary>Jakarta Slide, downloading</secondary>
        </indexterm> <indexterm id="http-webdav-ITERM-3341"
          significance="normal">
          <primary>downloading</primary>

          <secondary>Jakarta Slide</secondary>
        </indexterm> <indexterm id="http-webdav-ITERM-3342"
          significance="normal">
          <primary>Jakarta Slide, downloading</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3343"
          significance="normal">
          <primary>clients</primary>

          <secondary>WebDav</secondary>
        </indexterm>WebDAV) resource.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>To use Jakarta Slide 2.1 in a Maven 2 project, add the following
      dependency to your project's <filename>pom.xml</filename>:</para>

      <example id="http-webdav-ex-slide">
        <title>Adding a Dependency on Slide</title>

        <programlisting>    &lt;dependency&gt;
        &lt;groupId&gt;slide&lt;/groupId&gt;
        &lt;artifactId&gt;slide-webdavlib&lt;/artifactId&gt;
        &lt;version&gt;2.1&lt;/version&gt;
    &lt;/dependency&gt;  </programlisting>
      </example>

      <para>If you are not sure what this means, I'd suggest reading <ulink
      url="http://www.sonatype.com/books/maven-book">Maven: The Definitive
      Guide</ulink>. When you depend on a library in Maven 2, all you need to
      do is add the dependency <varname>groupId</varname>,
      <varname>artifactId</varname>, and <varname>version</varname> to your
      project's dependencies. Once you do this, Maven 2 will download the
      dependency and make it available on your project's classpath.</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>WebDAV, defined in RFC 2518, is an extension of HTTP/1.1, which
      supports distributed and collaborative authoring of content. Using a
      WebDAV client you can read, modify, copy, move, lock, and unlock
      resources, and you can read, enumerate, and modify properties associated
      with resources and collections of resources. Resources made available
      with WebDAV can be mounted as filesystems in Windows XP/2000, Mac OS X,
      and Linux, and the DAV protocol can be thought of as defining a
      filesystem built on top of HTTP/1.1. The WebDAV protocol is at the core
      of a number of distributed version control and content management
      systems.</para>

      <para>Jakarta Slide extends Jakarta HttpClient implementing <literal
      moreinfo="none">HttpMethod</literal> for the methods introduced by the
      WebDAV protocol. For example, the <literal
      moreinfo="none">LockMethod</literal> in the <literal
      moreinfo="none">org.apache.webdav.lib.methods</literal> package is an
      instance of <literal moreinfo="none">HttpMethod</literal> from Jakarta
      HttpClient, and just as WebDAV is an extension of HTTP/1.1, Jakarta
      Slide is an extension of Jakarta HttpClient. When dealing with
      authentication, cookie management, or redirects, you can configure
      Jakarta Slide the same way you would configure Jakarta HttpClient; to
      use Slide, you must create an instance of <literal
      moreinfo="none">HttpClient</literal>.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>For more information about the Jakarta Slide project... don't even
      bother. The slide project expired years ago. Please don't learn more
      about Slide just wait until this book is updated with content about
      Apache Jackrabbit. Sorry.</para>

      <para>It is far beyond the scope of this book to fully describe WebDAV,
      and attempting to do so in one or two recipes would not do it justice.
      WebDAV, like the protocol it extends, has the potential to transform the
      way people think about content creation, file sharing, and version
      control. To learn more about WebDAV, see the following resources:</para>

      <itemizedlist>
        <listitem>
          <para>RFC 2518 (HTTP Extensions for Distributed Authoring—WEBDAV) at
          <ulink
          url="http://www.zvon.org/tmRFC/RFC2518/Output/index.html">http://www.zvon.org/tmRFC/RFC2518/Output/index.html</ulink>.</para>
        </listitem>

        <listitem>
          <para><ulink
          url="http://www.webdav.org">http://www.webdav.org</ulink> is a hub
          for the WebDAV community. If you are interested in learning about
          WebDAV and a number of related specifications, see <ulink
          url="http://www.webdav.org/specs/">http://www.webdav.org/specs/</ulink>.
          For a list of software products that support WebDAV, see <ulink
          url="http://www.webdav.org/projects/">http://www.webdav.org/projects/</ulink>.</para>
        </listitem>

        <listitem>
          <para>Subversion is a great replacement for CVS from the Tigris
          community. You can configure Apache 2.0 to expose a Subversion
          repository via the WebDAV/DeltaV protocol using mod_dav_svn. For
          more information about Subversion and mod_dav_svn, see <ulink
          url="http://subversion.tigris.org">http://subversion.tigris.org</ulink>
          or <emphasis>Version Control with Subversion</emphasis> by Ben
          Collins-Sussman, Brian W. Fitzpatrick, and C. Michael Pilato
          (O'Reilly).</para>
        </listitem>
      </itemizedlist>

      <para>If you would like to set up your own WebDAV resource, I recommend
      installing the Apache HTTP Server with mod_dav. More information about
      installing "The Number One HTTP Server on the Internet" can be found at
      <ulink url="http://httpd.apache.org/">http://httpd.apache.org/</ulink>.
      Information about configuring mod_dav can be found at <ulink
      url="http://httpd.apache.org/docs-2.0/mod/mod_dav.html">http://httpd.apache.org/docs-2.0/mod/mod_dav.html</ulink>.
      The Jakarta Tomcat 5.0 distribution is bundled with a web application
      that exposes a resource using a WebDAV servlet. To download and install
      Jakarta Tomcat 5.0, see <ulink
      url="http://jakarta.apache.org/tomcat/">http://jakarta.apache.org/tomcat/</ulink>.</para>
    </sect2>
  </sect1>

  <sect1 id="http-webdav-sect-webdav" label="11.17" role="Recipe">
    <title>Connecting to WebDAV Resources</title>

    <warning>
      <para>Slide has died. While this section remains in the book, you should
      know that it will soon be replaced with a section devoted to <ulink
      url="http://jackrabbit.apache.org/">Apache Jackrabbit</ulink>: the
      successor to Jakarta Slide.</para>
    </warning>

    <sect2>
      <title>Problem</title>

      <para>You need to connect to a <indexterm class="startofrange"
          id="http-webdav-ITERM-3345" significance="normal">
          <primary>WebDav</primary>

          <secondary>connections</secondary>
        </indexterm> <indexterm class="startofrange"
          id="http-webdav-ITERM-3346" significance="normal">
          <primary>connections</primary>

          <secondary>WebDav</secondary>
        </indexterm> <indexterm class="startofrange"
          id="http-webdav-ITERM-3347" significance="normal">
          <primary>resources</primary>

          <secondary>WebDav</secondary>

          <tertiary>connections</tertiary>
        </indexterm>WebDAV resource and list the contents of a collection. As
      with most WebDAV resources, you need to supply <indexterm
          id="http-webdav-ITERM-3348" significance="normal">
          <primary>authentication</primary>

          <secondary>WebDav</secondary>
        </indexterm>authentication information.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Create an instance of <literal
      moreinfo="none">WebdavResource</literal>, passing in a URL and a
      <literal moreinfo="none">UsernamePasswordCredential</literal> object.
      List the contents of a WebDAV collection by calling the <literal
      moreinfo="none">listWebdavResources()</literal> <indexterm
          id="http-webdav-ITERM-3349" significance="normal">
          <primary>listWebdavResources( ) method</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3350"
          significance="normal">
          <primary>methods</primary>

          <secondary>listWebdavResources( )</secondary>
        </indexterm> method. The following example demonstrates the use of
      <literal moreinfo="none">WebdavResource</literal> to list the contents
      of a WebDAV collection:</para>

      <programlisting format="linespecific" id="I_11_tt479">
               <userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.Credentials;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpClient;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpException;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.UsernamePasswordCredentials;
<userinput moreinfo="none">import</userinput> org.apache.commons.lang.StringUtils;
<userinput moreinfo="none">import</userinput> org.apache.commons.lang.time.FastDateFormat;
<userinput moreinfo="none">import</userinput> org.apache.webdav.lib.WebdavResource;

HttpClient client = <userinput moreinfo="none">new</userinput> HttpClient( );

String url = "http://www.discursive.com/jccook/dav/";
Credentials credentials =
    <userinput moreinfo="none">new</userinput> UsernamePasswordCredentials("davuser", "davpass");

// List resources in top directory
WebdavResource resource = <userinput moreinfo="none">new</userinput> WebdavResource(url, credentials);
WebdavResource[] resources = resource.listWebdavResources( );
System.out.println( "type  name           size    type" +
                    "                   modified");
System.out.println( "-----------------------------------------" +
                    "---------------------------");
<userinput moreinfo="none">for</userinput>( <userinput moreinfo="none">int</userinput> i = 0; i &lt; resources.length; i++ )    {
    WebdavResource item = resources[i];
    String type;
    <userinput moreinfo="none">if</userinput>( item.isCollection( ) ) {
        type = "dir";
    } <userinput moreinfo="none">else</userinput> {
        type = "file";
    }
    System.out.print( StringUtils.rightPad( type, 6 ) );
    System.out.print( StringUtils.rightPad( item.getName( ), 15 ) );
    System.out.print( StringUtils.rightPad( item.getGetContentLength( ) 
    + "", 8 ) );
    System.out.print( StringUtils.rightPad( item.getGetContentType( ), 
    23 ) );
    Date lastMod = <userinput moreinfo="none">new</userinput> Date( item.getGetLastModified( ) );
    System.out.print( 
        StringUtils.rightPad( 
            FastDateFormat.getInstance( ).format( lastMod ), 25 ));
    System.out.print( "\n" );
}</programlisting>

      <para>The program connects to a WebDAV resource using the credentials
      supplied to the constructor of <literal
      moreinfo="none">WebdavResource</literal>. It lists the contents of a
      collection and produces the following output:</para>

      <programlisting format="linespecific" id="I_11_tt480">type  name           size    type                   modified
---------------------------------------------------------------------
file  test.html      14      text/html              5/6/04 12:16 AM          
file  index.html     14      text/html              5/5/04 11:59 PM          
dir   test           0       httpd/unix-directory   5/6/04 12:01 AM</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Jakarta Slide is built on top of Jakarta HttpClient, but you will
      notice that this recipe did not involve the execution of an <literal
      moreinfo="none">HttpMethod</literal>. This is because <literal
      moreinfo="none">WebdavResource</literal> manages the complexity of
      working with an instance of <literal
      moreinfo="none">HttpClient</literal> behind the scenes. The only trace
      of <literal moreinfo="none">HttpClient</literal> is the <literal
      moreinfo="none">UsernamePasswordCredentials</literal> object that is
      passed to the constructor of <literal
      moreinfo="none">WebdavResource</literal>. Because Jakarta Slide is built
      on top of Jakarta HttpClient, almost any feature of Jakarta HttpClient
      translates directly to Jakarta Slide. If you need to access a WebDAV
      repository over SSL with a self-signed certificate, or if you need to
      alter the cookie policy, you can use <indexterm class="endofrange"
      id="http-webdav-ITERM-3351" significance="normal"
      startref="http-webdav-ITERM-3345"></indexterm> <indexterm
      class="endofrange" id="http-webdav-ITERM-3352" significance="normal"
      startref="http-webdav-ITERM-3346"></indexterm> <indexterm
      class="endofrange" id="http-webdav-ITERM-3353" significance="normal"
      startref="http-webdav-ITERM-3347"></indexterm>the same facilities that
      are available to you when you are using <literal
      moreinfo="none">HttpClient</literal> directly.</para>
    </sect2>
  </sect1>

  <sect1 id="http-webdav-sect-modify-webdav" label="11.18" role="Recipe">
    <title>Modifying a WebDAV Resource</title>

    <warning>
      <para>Slide has died. While this section remains in the book, you should
      know that it will soon be replaced with a section devoted to <ulink
      url="http://jackrabbit.apache.org/">Apache Jackrabbit</ulink>: the
      successor to Jakarta Slide.</para>
    </warning>

    <sect2>
      <title>Problem</title>

      <para>You need to modify a<indexterm id="http-webdav-ITERM-3354"
          significance="normal">
          <primary>WebDav</primary>

          <secondary>modifying</secondary>
        </indexterm> <indexterm id="http-webdav-ITERM-3355"
          significance="normal">
          <primary>modifying WebDav</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3356"
          significance="normal">
          <primary>resources</primary>

          <secondary>WebDav</secondary>

          <tertiary>modifying</tertiary>
        </indexterm> WebDAV resource.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use the <literal moreinfo="none">putMethod( )</literal> <indexterm
          id="http-webdav-ITERM-3357" significance="normal">
          <primary>putMethod( ) method</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3358"
          significance="normal">
          <primary>methods</primary>

          <secondary>putMethod( )</secondary>
        </indexterm> on <literal moreinfo="none">WebdavResource</literal>, and
      be sure to lock and unlock the resource before and after modification.
      The following example demonstrates the use of <literal
      moreinfo="none">lockMethod( )</literal> <indexterm
          id="http-webdav-ITERM-3359" significance="normal">
          <primary>lockMethod( ) method</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3360"
          significance="normal">
          <primary>methods</primary>

          <secondary>lockMethod( )</secondary>
        </indexterm>, <literal moreinfo="none">putMethod( )</literal>, and
      <literal moreinfo="none">unlockMethod( )</literal> <indexterm
          id="http-webdav-ITERM-3361" significance="normal">
          <primary>unlockMethod( ) method</primary>
        </indexterm> <indexterm id="http-webdav-ITERM-3362"
          significance="normal">
          <primary>methods</primary>

          <secondary>unlockMethod( )</secondary>
        </indexterm> to modify a resource:</para>

      <programlisting format="linespecific" id="I_11_tt481">
               <userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.Credentials;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpClient;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.HttpException;
<userinput moreinfo="none">import</userinput> org.apache.commons.httpclient.UsernamePasswordCredentials;
<userinput moreinfo="none">import</userinput> org.apache.webdav.lib.WebdavResource;

String url = "http://www.discursive.com/jccook/dav/test.html";
Credentials credentials =
    <userinput moreinfo="none">new</userinput> UsernamePasswordCredentials("davuser", "davpass");

// List resources in top directory
WebdavResource resource = <userinput moreinfo="none">new</userinput> WebdavResource(url, credentials);

// Lock the Resource for 100 seconds
<userinput moreinfo="none">boolean</userinput> locked = resource.lockMethod( "tobrien", 100 );

<userinput moreinfo="none">if</userinput>( locked ) {
    <userinput moreinfo="none">try</userinput> {
        // Read content as a String
        String resourceData = resource.getMethodDataAsString( );
        
        // Modify a resource
        System.out.println( "*** Modifying Resource");
        resourceData = resourceData.replaceAll( "test", "modified test" );
        resource.putMethod( resourceData );
    } <userinput moreinfo="none">finally</userinput> {
        // Unlock the resource
        resource.unlockMethod( );
    }
}
        
// Close the resource    
resource.close( );</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para><literal moreinfo="none">lockMethod( )</literal> accepts an owner
      and a timeout; the owner is the owner of the lock, and the timeout is
      the timeout of the lock in number of seconds. When locking a resource,
      the <literal moreinfo="none">lockMethod( )</literal> will return a
      <literal moreinfo="none">boolean</literal> value: <literal
      moreinfo="none">true</literal> if the lock was granted and <literal
      moreinfo="none">false</literal> if the lock was not granted. The
      <literal moreinfo="none">resource.putMethod( )</literal> was called with
      a <literal moreinfo="none">String</literal> object, but it can also be
      invoked when a <literal moreinfo="none">byte[]</literal>, <literal
      moreinfo="none">InputStream</literal>, or <literal
      moreinfo="none">File</literal>. <literal moreinfo="none">putMethod(
      )</literal> returns a <literal moreinfo="none">boolean</literal> value:
      <literal moreinfo="none">true</literal> if the put was successful;
      otherwise, <literal moreinfo="none">false</literal>. The <literal
      moreinfo="none">unlockMethod( )</literal> unlocks the resource and makes
      it available for other clients to lock, modify, and unlock.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>Section 7 of RFC 2518 (HTTP Extensions for Distributed
      Authoring—WEBDAV) discusses the various types of write locks available
      in WebDAV. This RFC is available at <ulink
      url="http://www.zvon.org/tmRFC/RFC2518/Output/chapter7.html">http://www.zvon.org/tmRFC/RFC2518/Output/chapter7.html</ulink>.</para>

      <para>The Slide recipes in this chapter are only meant as a brief
      introduction to WebDAV. If you would like to learn more about how to
      work with properties, create collections, and search a WebDAV
      repository, please see the Jakarta Slide project page at <ulink
      url="http://jakarta.apache.org/slide">http://jakarta.apache.org/slide</ulink>.</para>
    </sect2>
  </sect1>
</chapter>
